[
["index.html", "경영데이터분석 참고자료 - R 기초 일러두기", " 경영데이터분석 참고자료 - R 기초 김길환 2021-03-12 일러두기 이 책은 경영데이터분석 수강생들을 위한 참고자료로 사용되기 위해 제작되었습니다. 본 강의 이외의 목적으로 사용하시는 것은 저자의 허가가 필요합니다. "],
["ch-intro.html", "Chapter 1 R 설치 및 시작 1.1 R 소개 1.2 R 설치하기 1.3 RStudio 1.4 RStudio로 R 시작하기", " Chapter 1 R 설치 및 시작 1.1 R 소개 R은 통계 계산과 그래픽을 위한 프로그래밍 언어이자 소프트웨어 환경이다. R은 1960년대와 1970년대 Bell 연구소에서 개발된 S라는 데이터 처리 언어에 기반을 두고 있다. 1990년대 중반 뉴질랜드 오클랜드 대학의 로스 이하카와 로버트 젠틀맨에 의해 시작되어 현재는 R의 핵심 기능은 R 코어 팀이, 다양한 추가 기능은 자발적 기여자들에 의해 개발되고 있다. R은 GPL 하에 배포되는 공개 소프트웨어로 누구나 자유롭게 이용할 수 있다. R은 빅데이터 분석에 널리 사용되고 있으며, 패키지 개발이 용이하여 통계 분석가들 사이에서 통계 소프트웨어 개발에 많이 쓰이고 있다. R은 데이터 조작, 계산, 그래픽 표현을 위한 소프트웨어이다. R의 주요 기능은 다음과 같다. 효율적이고 편련한 데이터 조작 및 처리 기능 데이트를 다양한 그래프로 표현해주는 데이터 시각화 기능 통계 분석 및 데이터 마이닝 알고리즘 수행 기능 분석 결과를 문서 및 발표 자료로 생성하는 기능 간단하며 효과적인 프로그래밍 언어로서의 기능 1.2 R 설치하기 1.2.1 R 배포판 내려받기 R을 설치하기 위해서는 R 배포판을 먼저 구해야 한다. R은 공개 소프트웨어이므로 무료로 R 공식 웹 사이트 (http://www.r-project.org/) 에서 내려받을 수 있다. R 공식 사이트의 첫 화면의 내용 중 download R 을 클릭하면 R 배포판을 내려받기할 CRAN 미러를 선택하는 화면으로 이동하게 된다. 지리적으로 가까운 CRAN 미러 서버를 선택하거나, 맨 위의 “0-Cloud”를 선택한다. 그러면 설치할 R 배포판을 선택하는 화면으로 이동한다. R 배포판을 선택하는 화면에서 Download R for Windows를 클릭하여 윈도우용 배포판을 선택한다.1 윈도우용 배포판 중 어떤 항목을 내려받을 것인지를 물어보는데 처음 설치하는 것이므로 Base를 선택한다. 그러면 32/64bits 겸용 윈도우용 R 바이너리 파일을 내려받을 수 있는 화면으로 이동한다. Download R x.x.x for windows를 클릭하여 배포판을 내려받는다. 여기서 x.x.x는 내려받기를 하는 R 배포판의 버전을 의미한다. 1.2.2 설치에 앞서 주의할 사항 한글 윈도우에서 R과 RStudio를 설치하여 사용할 때 이유를 알 수 없는 여러 문제가 발생할 수 있다. 이러한 문제의 대부분은 파일과 디렉토리(폴더)의 경로명에 한글이 들어간 경우에 발생한다. 특히 윈도우 사용자의 이름이 한글인 경우 이러한 문제가 빈번히 발생하는데, R이나 RStudio가 사용자 폴더의 하위 폴더에 필요한 파일과 디렉토리를 만들기 때문이다. 이러한 문제를 미연에 방지하려면 설치 전에 윈도우 사용자 이름이 한글인지 확인하고, 한글이면 영문 사용자 이름으로 관리자 계정을 하나 더 만들어 그 계정으로 R과 RStudio의 설치를 진행하는 것이 좋다. 물론 한글 사용자 이름을 사용하더라도 환경변수의 임시 디렉토리 설정을 변경하여 발생할 수 있는 대부분의 문제를 해결할 수 있지만, 새로운 패키나 함수를 사용할 때마다 이러한 문제가 잠복되어 있다가 다른 방식으로 다시 발생할 수 있다. R에 대한 이해가 높지 않은 초심자의 경우 이러한 문제가 발생하면 문제의 원인을 파악하기 어렵다. 그렇기 때문에 영문 이름으로 된 관리자 권한의 사용자로서 R과 RStudio를 설치하기를 강력히 권장한다. 1.2.3 R 설치하기 내려받은 R 설치 파일을 실행시켜 R을 설치한다. 설치 과정 중 사용할 언어 선택 화면이 나타나면 한국어를 선택한 후 [확인]을 클릭한다. GNU 라이선스 정보 화면이 나타나면 [다음]을 클릭한다. 설치할 위치를 선택하는 화면이 나타나면 [찾아보기]를 클릭하여 적절한 설치 폴더를 직접 지정하거나 기본 값으로 설치한다. [다음]을 클릭한다. 구성 요소 설치를 묻는 화면이 나타나면 위쪽에 있는 선택 리스트를 이용하여 32-bit 사용자 편의를 위한 쉬운 설치 또는 64-bit 사용자 편의를 위한 쉬운 설치 중 자신의 윈도우즈 시스템이 32-bit 윈도우인지 64-bit 윈도우인지에 따라 선택한다. 그리고 [다음]을 클릭한다.(자신의 윈도우 종류를 모르겠으면 사용자 편의를 위한 쉬운 설치를 선택하여 전체를 다 설치하여도 된다. Windows 10을 기준으로 몇 bits 운영체제인지를 확인하려면, 시작 메뉴에서 [제어판]을 선택한 후 [시스템]-[정보]를 선택하면 시스템 종류에 해당 정보가 나온다.) R을 시작할 때의 사용하는 스타트업 옵션을 조정할 것인지를 묻는 화면이 나온다. 지금은 그냥 No (기본값 사용)을 선택하도록 한다. 그리고 [다음]을 클릭한다. 시작 메뉴 폴더를 선택하도록 하는데, 기본 값인 `R’을 이용하도록 한다. [다음]을 클릭한다. 추가 사항 적용은 특별한 요구가 없는 한 기본 설정을 이용하도록 한다. [다음]을 클릭하면 설치가 실행된다. 설치가 완료되면 [완료]를 클릭한다. 윈도우즈 시작 메뉴에 가면 R 폴더가 생성되어 있고 그 안의 메뉴를 클릭하면 R이 실행된다. 1.3 RStudio R 배포판이 제공하는 기능만으로도 기본적인 프로그래밍이나 데이터 분석이 가능하다. 그러나 프로그래밍이나 데이터 분석 작업이 복잡해지면 R을 좀 더 편리하게 사용할 수 있는 통합된 개발 환경(IDE: Integrated Development Environment)이 큰 도움이 된다. RStudio는 R을 위한 강력한 통합 개발 환경을 제공해 준다. R과 마찬가지로 공개 소프트웨어로 누구나 자유롭게 이용할 수 있다. 따라서 많은 R 사용자가 RStudio를 사용하고 있다. 1.3.1 RStudio 설치 RStudio 웹페이지(http://www.rstudio.com/products/rstudio/download/) 에 접속하면 RStudio를 내려 받을 수 있다. RStudio는 데스크탑용과 서버용이 있다. 데스크탑 버전은 개별 사용자를 위한 버전이고, 서버용 버전은 여러 사람이 동시에 데이터를 분석하거나 원격에서 데이터를 분석하기에 좋은 환경이다. 서버용 버전의 관련 정보는 RStudio 홈페이지를 참조하기 바란다. RStudio Desktop은 무료용 Open Source License (Free) 버전과 상업용 Commercial License 버전이 있다. 데스크탑용 RStudio는 무료용이나 상업용이나 기능상 차이는 없다. 상업용에는 별도의 기술 지원이 추가된다. Open Source License (Free)에서 [DOWNLOAD]을 클릭하여 다운로드 페이지로 이동한다. 자동으로 접속자의 환경을 파악하여 적절한 운영체제의 RStudio 데스크탑 버전을 선택해 준다. 윈도우즈 사용자들은 [DOWNLOAD RSTUDIO FOR WINDOWS]가 나타날 것이다. 이를 클릭하면 RStudio가 다운로드 될 것이다. 만약 다른 운영체제의 RStudio가 필요하면 하단의 목록에서 적절한 배포판을 선택한다. (RStudio는 공개 소프트웨어로 프로그램 소스 파일도 함께 공개되어 있어, 같은 페이지 하단에서 볼 수 있는 바와 같이 RStudio 소스를 내려받을 수도 있다.) 내려받은 파일을 실행하면 RStudio 설치를 완료할 수 있다. 1.4 RStudio로 R 시작하기 RStudio를 설치하면 윈도우 시작메뉴에 RStudio를 실행할 수 있는 메뉴가 나타난다. 이를 실행하면 다음 그림처럼 RStudio가 실행된다. 기본 설정은 왼편에 R 콘솔이나 코드 편집기 창들이 위치하고, 오른편에 작업 환경, 명령어 히스토리, 파일, 그림, 패키지, 도움말 관련 창들이 위치하도록 되어 있다. 1.4.1 R 콘솔과 프롬프트 R은 기본적으로 텍스트 기반의 명령문을 입력받아 명령문에 대해 응답하는 대화형 방식으로 작동한다. R 콘솔은 사용자의 명령문을 입력받고 텍스트 기반 결과물을 출력하는 곳이다. R 콘솔은 사용자의 명령을 받을 준비가 되어 있다는 것을 나타내기 위해 명령 프롬프트인 `&gt;’ 기호를 표시한다. 프롬프트가 보이면 R 명령문을 입력하고 Enter 키를 누르면 입력된 R 명령문이 R에 전달되어 실행된다. 명령문의 실행 결과가 텍스트이면 R 콘솔에 결과가 나타나고 그래프이면 오른편의 Plots 창에 그래프가 나타난다. 이 책에서는 아래에 나오는 형태로 R 콘솔의 입출력을 표시한다. &gt;가 있는 행은 사용자가 입력한 행이고 &gt;가 없는 행은 R의 출력 결과로 표시한다. R을 맛보기 위해 R이 제공하는 cars 데이터에 대해 기초적인 분석을 수행해보자. 이 절에서 이용되는 R 명령어에 대해서는 현재 시점에선 이해할 필요가 없다. 이 책이 진행되면서 차근차근 설명될 것이다. 먼저 다음과 같이 cars 데이터를 화면에 출력해 보자. 콘솔에 cars라고 입력 후 Enter를 입력한다. &gt; cars speed dist 1 4 2 2 4 10 3 7 4 4 7 22 5 8 16 6 9 10 ... cars 데이터는 자동차의 속력(speed)과 제동 거리(dist)에 대한 50 개의 관찰 사례로 구성되어 있다. cars 데이터에 대하여 자세한 정보를 얻어보자. ?를 명령어에 붙이면 명령어에 대한 설명을 오른편의 Help 창에 도움말이 나타난다. &gt; ?cars summary() 함수를 이용하여 자동차의 속력과 제동 거리에 대한 최소값, 최대값, 평균, 사분위수 등 기본 통계치를 구해 보자. &gt; summary(cars) speed dist Min. : 4.0 Min. : 2.00 1st Qu.:12.0 1st Qu.: 26.00 Median :15.0 Median : 36.00 Mean :15.4 Mean : 42.98 3rd Qu.:19.0 3rd Qu.: 56.00 Max. :25.0 Max. :120.00 자동차의 속력과 제동 거리의 상관 관계를 보기 위해 plot() 함수를 이용하여 산점도(scatter plot)를 그려 본다. &gt; plot(cars) 자동차의 속력과 제동 거리의 관계를 선형 모형으로 나타내기 위해 다음 명령어를 이용하여 cars 데이터에 대한 선형회귀분석을 수행한다. &gt; lm.cars &lt;- lm(dist ~ speed, data=cars) &gt; lm.cars Call: lm(formula = dist ~ speed, data = cars) Coefficients: (Intercept) speed -17.579 3.932 제동 거리를 속도로 회귀분석해 보면 절편이 -17.579이고 기울기가 3.932가 됨을 알 수 있다. 앞에 그린 산점도에 abline() 함수를 이용하여 회귀 적합선을 그려 넣어 본다. &gt; plot(cars) &gt; abline(lm.cars, col=&quot;blue&quot;) 본 절에서 수행한 명령어가 궁금한 독자는 궁금한 명령에 대하여 help(명령어)나 ?명령어를 R 콘솔에 입력해 보라. 관련 도움말을 얻을 수 있을 것이다. 1.4.2 R 콘솔 사용과 관련된 몇 가지 팁 입력 시 주의 사항 R 명령문은 대문자와 소문자를 다른 문자로 간주한다. 그러니 함수명이나 변수명을 입력할 때 대소문자가 틀리지 않도록 해야 한다. 명령어의 철자가 틀려서 명령어가 실행되지 않는 일이 빈번히 발생한다. 그렇기 때문에 뒤에서 설명하는 코드 자동완성 기능을 사용하여 명령어를 완성하는 습관을 갖는 것이 좋다. 그래야 철자 오류 때문에 발생하는 명령 오류를 최소화할 수 있다. R 명령문 입력시 가장 많이 틀리는 부분이 ' ', \" \", ( ), { } 등이 서로 짝이 맞지 않는 경우다. R 명령문을 입력하고 Enter를 입력하였는데, 결과가 출력되지 않고 프롬프트가 +로 바뀌는 경우에는, 입력한 명령문이 완전하지 않기 때문에 나머지 입력을 받기 위해 기다리고 있다는 것을 나타낸다. 주로 앞서 설명한 ' ', \" \", ( ), { } 등이 서로 맞지 않아 발생하는 경우가 많다. 이를 해결하는 두 가지 방법이 있다. 명령문의 나머지를 + 프롬프트 뒤에 입력한 후 Enter를 입력하여 명령문을 마무리하거나, Esc를 눌러 지금까지 입력된 내용을 취소하는 것이다. RStudio의 콘솔은 몇 가지 편의 기능을 제공한다. 이 기능들을 이용하면 작업의 생산성을 향상시킬 수 있다. 코드 완성 RStudio 콘솔에서 Tab 키를 사용하여 코드를 자동 완성시킬 수 있다. 예를 들어 앞 절에 나온 lm.cars 변수를 사용하는 예제를 수행한 뒤라면, lm.c 까지만 입력한 후 Tab 키를 눌러보자. 그러면 자동으로 변수의 전체 이름을 완성해 줄 것이다. 코드 완성 기능을 이용하여 변수 이름을 입력하는 것을 습관화 하면 좋다. 변수의 이름을 잘못 입력하여 발생하는 오류를 줄일 수 있다. 코드 완성 기능은 함수에도 이용할 수 있다. sum까지만 입력한 후 Tab을 눌러보자. 그러면 다음 그림 처럼 sum으로 시작하는 함수의 목록이 나타난다. 목록 중 원하는 함수를 선택하면 해당 함수 이름을 콘솔에 자동 완성해 준다. 필요한 함수의 정확한 이름이 생각나지 않을 때 매우 유용하다. 코드 완성 기능은 함수의 인수 입력에도 이용할 수 있다. summary(라고 입력한 후에* Tab 키를 누르면 함수 인수의 목록과 설명이 나온다. R 함수들의 인수 이름을 정확히 기억하는 것은 쉽지 않다. 코드 완성 기능을 오류 없이 정확한 명령어를 빠르게 입력할 수 있도록 도와준다. 이전 명령문 불러오기 R 콘솔에서는 이전에 입력한 명령을 불러와 다시 실행하거나 수정하여 실행시킬 수 있다. 이전 명령은 위와 아래 화살표 키를 이용하여 불러온다. [위 화살표 키] 이전에 입력한 명령을 차례대로 불러온다. [아래 화살표 키] 위 화살표 키와 반대로 불러온다. [Ctrl + 위 화살표 키] 이전 명령의 목록을 보여준다. 1.4.3 R 스크립트 파일 만들기 R 콘솔에서 대화 형식으로 명령문을 입력하고 결과를 받는 것은 단순한 작업의 경우에는 편리하지만, 복잡한 분석을 위해 입력해야 할 명령문이 많거나 추후에 동일한 또는 유사한 작업을 할 예정이라면 R 스크립트 파일을 작성하여 명령문을 저장해 두는 것이 좋다. R 스크립트는 R에서 한꺼번에 실행할 명령문의 묶음을 단순한 텍스트 형식으로 기술한 파일이다. R 스크립트에는 실행할 명령문을 한 줄씩 입력한다. R은 스크립트를 읽어들여서 줄바꿈이 되는 곳을 기준으로 하나의 명령문으로 간주하여 한 줄씩 처리한다. 다음은 앞에서 콘솔에서 수행한 명령문을 R 스크립트로 작성한 예이다. 콘솔에서 입력한 명령을 그대로 텍스트 파일에 기술하면 된다. 다만 콘솔에 나타나는 프롬프트나 결과는 스크립트에 저장하지 않는다. 사용자가 직접 입력하는 명령문만 스크립트에 기술한다. summary(cars) lm.cars &lt;- lm(dist~speed, data=cars) lm.cars plot(dist~speed, cars) abline(lm.cars) RStudio 코드 편집기 RStudio의 코드 편집기는 R 스크립트 등 다양한 R 관련 파일을 작성하는 것을 도와준다. 문법 강조 표현, 코드 완성 등 다양한 기능들을 가지고 있다. 또한 코드 편집기에 입력한 R 명령을 콘솔에서 즉시 실행해 볼 수도 있다. 많은 R 사용자가 R 명령을 콘솔에서 직접 실행하는 것보다 코드 편집기에서 스크립트로 작성한 후 실행하는 것을 선호한다. 왜냐하면 코드 편집기를 이용하면 실행한 R 명령을 파일에 저장해 둘 수 있으므로, 나중에 동일한 코드를 재실행할 수 있을 뿐 아니라 함수 등으로 쉽게 변환할 수 있기 때문이다. RStudio에서 지원하는 주요 파일 형식 RStudio는 다음 형식의 파일에 대하여 문법 강조 표현 및 특화된 코드 편집 기능을 제공한다. R 스크립트: R 명령어 코드와 주석만을 포함하는 파일이다. R 노트북: R 명령어와 함께 실행 결과를 Mathematica 노트북 형태로 저장해주는 파일이다. R Markdown 문서: 마크다운이라는 매우 단순한 형식으로 문서 모양을 지정할 수 있다. R 명령어와 마크다운이 같이 한 문서에 사용되어 동적인 문서를 생성한다. R 마크다운으로 작성된 문서는 HTML, 워드 문서, PDF 문서로 최종 결과를 출력할 수 있다. Shiny Web App: RStudio에서 개발한 R을 이용해 웹 응용을 쉽게 개발하도록 지원하는 웹 응용 개발 체계이다. R Sweave 문서: LaTex 문서 내에 R 명령어를 포함하여 동적인 LaTex 파일을 만들어 주는 파일 형식이다. R HTML 문서: HTML 문서 내에 R 명령어를 포함하여 동적으로 HTML 파일을 만들어 주는 파일 형식이다. R Presentation 문서: HTML5 기능을 이용하여 HTML 기반의 동적인 프리젠테이션 파일을 만들어 주는 파일 형식이다. R Documentation 문서: R 프로그램에 대한 문서화를 지원해 주는 파일 형식이다. 스크립트 파일 만들기 일반적인 사용자는 보통 R 스크립트 파일, R 마크다운 파일, R 프리젠테이션 파일을 많이 사용한다. RStudio에서 새로운 파일을 생성하려면 File-&gt;New File 메뉴를 이용하거나 다음처럼 새 파일을 만드는 명령 단추를 클릭한다. 기존 파일을 열기 위해서는 File-&gt;Open File… 또는 File-&gt;Recent Files 메뉴를 이용하거나, 파일 열기 명령 단추를 클릭한다. RStudio에서 여러 파일을 열게 되면 탭으로 각 파일을 표시해 준다. 매우 많은 파일이 열려서 탭을 모두 표시할 수 없으면 우측 상단에 &gt;&gt; 또는 좌측 상단에 &lt;&lt; 아이콘이 표시되어 보이지 않는 파일 탭 사이를 전환할 수 있도록 해 준다. 편집기의 코드 완성 기능 코드 편집기는 Tab 키를 이용하여 자동 코드 완성을 지원한다. 코드 완성 기능은 콘솔과 마찬가지니 콘솔의 설명을 참조하기 바란다. 문자 찾기와 바꾸기 코드 편집기는 문서의 문자를 찾거나 바꾸는 기능을 지원한다. Ctrl +F 단축키를 이용하거나 Edit-&gt;Find 또는 Edit-&gt;Replace and Find 메뉴를 이용한다. 코드 실행 RStudio는 코드 편집기의 코드를 직접 실행시킬 수 있다. 실행할 코드는 콘솔에 자동 입력되어 실행되고 그 결과도 콘솔에 표시된다. 코드의 한 줄 또는 일부 여러 줄을 실행하려면 그 줄을 선택한 후 코드 편집기의 도구 모음에서 Run를 실행하거나 Ctrl+Enter 키를 이용한다. 코드 전체를 실행하기 위해서는 코드 편집기의 도구 모음에서 Source -&gt; Source with Echo를 실행하거나 Ctrl+Shift+Enter 키를 이용한다. 코드 편집기의 도구 모음에서 그냥 Source를 실행하면 파일의 명령문이 실행은 되나 결과가 콘솔에 출력되지 않는다. 주석 처리 R 스트립트에 명령문이 아닌 내용을 입력하고 싶으면 #을 앞에 사용하여 주석 처리를 한다. # 뒤에 입력된 내용은 명령문으로 간주하지 않고 무시한다. 주석문은 명령문의 의미를 나중에 이해하기 쉽도록 기술하거나, R 스크립트 개발 과정에서 디버깅이나 다른 이유로 명령문을 실행에서 제외할 때 사용한다. 직접 #를 입력하는 방법뿐 아니라, Edit-&gt;Comment/Uncomment Lines 메뉴나 코드 편집기 상단의 코드 명령 단추에서 해당 메뉴를 이용하면 선택한 코드 부분 전체를 주석 처리하거나 주석 처리를 취소할 수 있다. 들여쓰기 코드를 작성할 때 동일한 논리적 단위들을 동일하게 들여쓰기하면 코드를 읽기가 쉬워진다. RStudio는 코드 작성시 현재의 들여쓰기 옵션에 따라 자동으로 들여쓰기를 해 준다. 코드를 작성한 후 들여쓰기를 직접 조정하고 싶으면, 코드를 선택한 후 Tab 키를 누른다. 그러면 Tab 키를 누른 횟수만큼 들여쓰기가 된다. 반대로 Shift+Tab 키를 누르면, 누른 횟수만큼 내어쓰기가 된다. 참고로 RStudio는 Tab 한 회에 공백 2문자만큼 들여쓰기를 한다. 이를 조절하고 싶으면 [Toos]-[Global Options]-[Code] 메뉴에 가서 Tab 한 회당 들여쓰기할 공백 문자 수를 조절하면 된다. 이 책에서는 윈도우에 R을 설치한다고 가정한다. R 배포판은 설치 방법이나 그래픽 인터페이스의 몇 가지 기능을 제외하고 운영 체제에 따른 차이는 없다. ↩︎ "],
["ch-R-Data-Basic.html", "Chapter 2 R 데이터 형식과 변수 2.1 단순한 데이터 형식 2.2 숫자 연산 2.3 논리값 연산 2.4 문자열 연산 2.5 변수와 할당 2.6 함수를 이용한 연산", " Chapter 2 R 데이터 형식과 변수 R은 통계 데이터 분석 툴이기도 하지만 그 자체로 프로그래밍 언어이다. 한국어, 영어와 같은 모든 언어가 그러하듯이 R에도 자기만의 어휘와 표현법, 표현 형태들이 있다. 외국어에 익숙해지려면 기본적인 문법 요소와 다양한 문형들을 익혀야 하는 것처럼 R도 R의 기본 표현법과 표현 형태를 익혀야만 사용할 수 있다. 고급 문법과 문형에 익숙할수록 더 유창한 언어 실력을 보일 수 있듯이 R도 고급 표현을 익히면 더 다양한 분석을 수행할 수 있다. 이 장에서는 R의 가장 기초적인 데이터 요소를 배운다. 이 장의 내용은 프로그래밍 언어에 익숙한 독자들에게는 이미 익숙한 내용일 것이다. 그런 독자들은 다음 장부터 시작하여도 무방하다. 2.1 단순한 데이터 형식 2.1.1 R의 기본적 데이터 형식: 숫자, 문자열, 논리값 R은 데이터를 다룬다. 그러므로 R에서 다룰 수 있는 데이터 형식을 이해하는 것이 무엇보다 중요하다. R에서 다루는 기본적인 데이터 형식(data type)으로는 숫자, 문자열, 논리값, raw 형식이 있다. 어떤 학생의 키가 172.2이면 이 데이터의 형식은 숫자이다. 그 학생의 이름이 `홍길동’이면 이 데이터는 문자열 데이터이다. 그리고 이 학생이 남자인지 여부를 TRUE 또는 FALSE로 표현하였다면 이 데이터의 형식은 논리값이다. 대부분의 통계 데이터의 형태는 이러한 숫자, 문자, 논리값을 기반으로 구성된다. R에서는 숫자, 문자열, 논리값 말고도 raw라는 바이트 형식도 있다. 음원이나 이미지 데이터를 처리하려면 바이트 형식의 데이터를 처리하여야 한다. 그러나 통계 분석에서는 거의 사용되지 않는 타입이어서 이 책에서는 따로 설명하지 않도록 한다. 다음은 R의 콘솔에서 숫자, 문자열, 논리값을 차례대로 입력한 예이다. &gt; 다음 부분을 R 콘솔에 입력한 후 Enter 키를 누른다. 그러면 입력한 내용이 R에 전달되어 출력 결과가 그 다음 줄에 나타난다(&gt;가 없는 줄). &gt; 10 [1] 10 &gt; TRUE [1] TRUE &gt; &quot;홍길동&quot; [1] &quot;홍길동&quot; 2.1.2 10 vs “10” 여기서 주의할 점은 숫자와 논리값과는 달리 문자 데이터는 따옴표로 시작과 끝을 표현해 주어야 한다는 것이다. 큰 따옴표나 작은 따옴표를 모두 사용할 수 있으나, 시작과 끝의 따옴표의 종류가 같아야 한다. 따라서 사칙연산이 가능한 숫자 10과 문자열 “10”은 서로 다르다. 숫자 10은 더하기나 빼기 가능하지만, 문자열 “10”은 더하기나 빼기 등의 수학적 연산이 불가능하다.2 마찬가지로 논리값 TRUE와 문자열 “TRUE”도 다른 의미를 가진다. 논리값 TRUE로는 논리 연산이 가능지만 문자열 “TRUE”로는 논리적 연산이 불가능하다. 문자열 데이터에 따옴표를 사용하는 이유는 plot이라는 문자를 그대로 입력할 수 있다고 하면, 그래프를 그리라는 plot() 함수 명령어인지, \"plot\"이라는 문자열인지 구분할 수 없을 것이다. 그렇기 때문에 대부분의 프로그래밍 언어에서 문자열 데이터를 따옴표를 사용하여 표현한다. 2.2 숫자 연산 2.2.1 사칙 연산 R은 숫자 형식의 데이터에 대하여 더하기, 빼기, 곱하기, 나누기 등의 사칙연산에 대한 기본적 기능을 제공한다. 아래의 &gt; 이후의 부분을 입력 후 Enter 키를 누르면 그 아래에 출력 결과가 나온다. &gt; 2 + 2 [1] 4 &gt; 2 - 2 [1] 0 &gt; 2 * 2 [1] 4 &gt; 2 / 2 [1] 1 2.2.2 거듭 제곱 연산 또한 ^ 연산자를 이용해 거듭제곱도 가능하다. 아래의 예는 2의 1제곱부터 4제곱까지의 결과이다. 여기서 4개의 거듭제곱 연산 명령문 (Enter 키를 쳐서 R로 보내는 내용)을 한 줄로 보내기 위해 ;로 각각의 명령문을 나누어 한번의 Enter 키로 명령을 실행하였다. 각 명령문의 결과는 다른 줄로 출력되었음을 볼 수 있다. &gt; 2^1; 2^2; 2^3; 2^4 [1] 2 [1] 4 [1] 8 [1] 16 거듭제곱 연산자로 ^ 대신 Python에서처럼 ** 연산자를 대신 사용할 수도 있다. &gt; 5^3 [1] 125 &gt; 5**3 [1] 125 2.2.3 몫과 나머지 R에서 나눗셈은 소수점 형식의 실수(real numbers)로 계산된다. 만약 정수의 나눗셈에서 몫과 너머지를 구하려면 %/%과 %% 연산자를 사용한다. &gt; 11 / 3 # 실수로 나눗셈 [1] 3.666667 &gt; 11 %/% 3 # 몫 [1] 3 &gt; 11 %% 3 # 나머지 [1] 2 2.2.4 비교 연산 그리고 == vs. = R은 사칙연산뿐 아니라 부등호와 등호를 이용한 비교연산도 가능하다. 아래는 비교 연산을 수행한 경우이다. &gt;=와 &lt;= 연산자는 같거나 크다 또는 같거나 작다를 의미한다. == 연산자는 같다를 의미하고 != 연산자는 같지 않다를 의미한다. 여기서 주의할 점은 등호가 =가 아니라 ==라는 점이다. = 연산자는 뒤에서 살펴보겠지만 변수에 값을 할당하는데 이용된다. &gt; 2 &gt; 2; 2 &gt;= 2; 2 &lt; 2 ; 2 &lt;= 2 [1] FALSE [1] TRUE [1] FALSE [1] TRUE &gt; 2 == 2; 2 != 2 [1] TRUE [1] FALSE 2.3 논리값 연산 논리값은 &amp;, |, !, xor(x, y) 연산자를 이용하여 논리적 AND, OR, NOT, XOR 연산의 수행도 가능하다. &gt; TRUE &amp; FALSE [1] FALSE &gt; TRUE | FALSE [1] TRUE &gt; !TRUE [1] FALSE &gt; xor(TRUE, TRUE) [1] FALSE 다음처럼 숫자의 비교 연산과 함께 사용되어 복잡한 연산을 수행할 수 있다. &gt; (3 &lt; 5) &amp; (5 &lt; 7) [1] TRUE &gt; (3 &lt; 9) &amp; (9 &lt; 7) [1] FALSE &gt; (3 &lt; 9) | (9 &lt; 7) [1] TRUE 2.4 문자열 연산 2.4.1 문자열 결합 연산: paste() 문자열에 대한 연산으로는 paste() 함수를 이용하여 문자열을 연결하는 연산이 있다. paste() 함수는 문자열을 공백 하나를 사이에 두고 하나의 문자열로 합쳐준다. 숫자처럼 문자가 아닌 것은 문자로 변환한 후 합쳐준다. sep인자를 이용하면 두 문자열의 사이에 다양한 문자를 넣을 수 있다. &gt; paste(&quot;대한민국&quot;, &quot;충청남도&quot;, &quot;천안&quot;) [1] &quot;대한민국 충청남도 천안&quot; &gt; paste(&quot;대한민국&quot;, &quot;충청남도&quot;, &quot;천안&quot;, sep=&quot;-&quot;) [1] &quot;대한민국-충청남도-천안&quot; &gt; paste(&quot;대한민국&quot;, &quot;충청남도&quot;, &quot;천안&quot;, sep=&quot;/&quot;) [1] &quot;대한민국/충청남도/천안&quot; &gt; paste(&quot;대한민국&quot;, &quot;충청남도&quot;, &quot;천안&quot;, sep=&quot;&quot;) [1] &quot;대한민국충청남도천안&quot; 공백 없이 문자열을 연결하는 경우가 매우 빈번하기 때문에 R은 이를 수행하는 paste0()라는 함수도 제공한다. &gt; paste0(&quot;3&quot;, &quot;학년&quot;) [1] &quot;3학년&quot; 2.4.2 문자열 분리 연산: strsplit() paste()와 반대로 하나의 문자열을 여러 문자열로 분리해 내는 strsplit() 함수도 있다. split인자에 문자열을 분리하는 기준이 되는 문자 또는 문자열을 지정해 준다. 다음은 날짜와 시간을 나타내는 문자열을 여러 지점에서 분리해보는 예이다. &gt; strsplit(&quot;2021-3-11 11:16:22&quot;, split=&quot; &quot;) [[1]] [1] &quot;2021-3-11&quot; &quot;11:16:22&quot; &gt; strsplit(&quot;2021-3-11 11:16:22&quot;, split=&quot;-&quot;) [[1]] [1] &quot;2021&quot; &quot;3&quot; &quot;11 11:16:22&quot; &gt; strsplit(&quot;2021-3-11 11:16:22&quot;, split=&quot;:&quot;) [[1]] [1] &quot;2021-3-11 11&quot; &quot;16&quot; &quot;22&quot; &gt; strsplit(&quot;2021-3-11 11:16:22&quot;, split=&quot;16&quot;) [[1]] [1] &quot;2021-3-11 11:&quot; &quot;:22&quot; strsplit()의 split 인자는 사실 정규식 표현도 가능하다. (정규식에 대해서는 regular expression에 대한 다른 자료를 참조하길 바란다.) 다음은 정규식을 이용하여 -나, (공백)나, : 문자가 있는 곳 모두를 분리한 예이다. &gt; strsplit(&quot;2016-3-11 11:16:22&quot;, split=&quot;[- :]&quot;) [[1]] [1] &quot;2016&quot; &quot;3&quot; &quot;11&quot; &quot;11&quot; &quot;16&quot; &quot;22&quot; 2.5 변수와 할당 2.5.1 변수는 메모리 공간에 붙이는 레이블 R에서 연산을 수행하다 보면 연산의 중간 결과를 저장해둘 필요가 있다. 이 때 이용할 수 있는 것이 변수이다. 변수는 데이터를 저장해 두는 공간이라고 생각하면 이해하기 쉽다. 변수는 사실 데이터를 저장해 두는 공간에 레이블을 붙여두는 것이다. 다시 그 데이터가 필요할 때 레이블을 이용하여 데이터가 저장된 공간에 가서 그 데이터 값을 가져와 이용하게 된다. 2.5.2 변수명에 대한 규칙 변수란 데이터 저장 공간에 붙이는 레이블이라고 했다. 이 레이블을 변수 이름 또는 변수명이라고 한다. 변수명은 분석자가 자유롭게 부여할 수 있으나 몇 가지 제약 사항이 있다. 변수명에는 알파벳, 숫자, _, .을 사용할 수 있다. 따라서 다음은 모두 적절한 변수명이다. sales TV_sales TV_5_sales TV.sales TV.5.sales 주의할 점은 -은 변수명에 사용될 수 없다. 만약 a-b라는 변수명이 있으면 이 표현이 a라는 변수의 값에서 b라는 변수의 값을 빼라는 명령인지, a-b라는 변수인지 구별할 수 없기 때문이다. 변수명은 알파벳이나 .으로 시작할 수 있으나 숫자나 _로는 시작할 수 없다. 그리고 .으로 변수명을 시작했으면 그 다음에는 반드시 알파벳이 변수명에 사용되어야 한다. 따라서 다음은 잘못된 변수명이다. _sales 5sales 변수명으로 R에서 기본으로 제공하는 명령어를 사용할 수 없다. 2.5.3 변수에 값 할당하기 할당(assignments)이란 어떤 변수에 데이터를 저장하는 것을 말한다. 예를 들어 x에 5라는 숫자 데이터를 할당하였다면 5라는 숫자가 x라는 레이블이 붙은 저장 공간에 들어간 것과 마찬가지이다. 우리는 x라는 레이블을 이용하여 필요할 때 x라는 레이블이 붙은 저장공간에 저장된 데이터 값을 가져올 것이다. 2.5.4 할당 연산자 변수에 데이터를 할당하는 것은 &lt;- 또는 = 연산자를 이용하여 이루어진다. 이 책에는 할당 연산자로 &lt;-을 이용할 것이다. 주의할 점은 &lt; -처럼 띄워쓰면 안되고 항상 &lt;-처럼 붙여써야 R은 할당 연산자로 이해를 한다. 할당 연산자의 모양에서도 알 수 있듯이 &lt;- 연산자 오른쪽의 데이터를 왼쪽의 변수에 집어넣는다. x라는 변수에 저장된 데이터 값을 알고 싶으면 x를 입력한 후 Enter 키를 누르면 x의 값이 출력된다. &gt; x &lt;- 5 &gt; x [1] 5 2.5.5 연산에 변수 사용하기 x를 이용하여 다양한 명령을 수행할 수 있다. 뿐만 아니라 괄호 등을 이용하여 복잡한 연산을 수행할 수 있다. &gt; x + 2 [1] 7 &gt; x * 2 [1] 10 &gt; x^2 [1] 25 &gt; (x+3)^2 + 5 [1] 69 &gt; x [1] 5 위의 마지막 결과에서 볼 수 있듯이 변수의 값은 &lt;- 연산자에 의해 다시 다른 값으로 할당되지 않으면 연산에서 사용되어도 원래의 값이 변하지 않는다. 2.5.6 변수에 값 재할당하기 변수는 데이터의 저장공간일 뿐이므로 현재 들어간 데이터 값 대신 다른 값을 재할당할 수도 있다. 다음의 예는 x에 7을 재할당한 후 앞서 수행한 연산을 다시 수행해 본 것이다. &gt; x &lt;- 7 &gt; x + 2 [1] 9 &gt; x*2 [1] 14 &gt; x^2 [1] 49 &gt; 2^x [1] 128 이제 x라는 레이블이 붙은 저장공간에 7이라는 숫자 데이터가 들어가 있으므로 x를 이용한 연산 결과가 앞의 예와는 다르게 나옴을 볼 수 있다. 2.5.7 할당문은 우변이 수행된 후 좌변으로 할당이 이루어진다. 한 명령문 안에서 x의 값을 가져와 연산에 이용한 후 그 결과를 다시 x에 재할당할 수 있다. 이 경우 &lt;- 연산자 오른편의 연산이 먼저 수행된 후 &lt;- 연산자에 의해 왼편의 변수로 할당이 이루어진다. &gt; x &lt;- x + 1; x [1] 8 &gt; x &lt;- 2 + x; x [1] 10 &gt; x &lt;- x*2; x [1] 20 &gt; x &lt;- x^2; x [1] 400 마찬가지로 한 변수의 값을 이용하여 연산을 수행한 후 다른 변수에 값을 할당할 수도 있다. 아래 예에서도 볼 수 있듯이 x가 연산에 이용되더라도 재할당이 이루어지지 않으면 x라고 레이블이 붙은 저장공간에 들어가 있는 데이터 값은 동일하다. &gt; x [1] 400 &gt; y &lt;- 2 * x &gt; y [1] 800 &gt; x [1] 400 여기서도 변수의 값은 할당문에 의해 할당 또는 재할당이 이루어지지 않으면 변화가 없음을 다시 확인할 수 있다. 2.5.8 변수 제거하기: rm() 변수를 생성하면, 그 변수는 R 세션이 종료될 때까지 유지된다. 만약 RStudio를 종료하여 수행하던 R 세션이 종료되면 변수에 저장하였던 데이터는 사라진다. 만약 변수에 저장된 데이터를 다음에도 사용하려면 별도의 파일에 데이터를 저장하여야 한다. 그런데 여러 가지 이유로 R 세션 종료 전에 변수를 제거하고 싶을 때가 있다. 사용하던 변수를 제거하려면 rm() 함수를 이용하면 된다. 제거할 변수를 rm() 함수 내에 기술하면 이 변수가 사라지게 된다. &gt; x; y [1] 400 [1] 800 &gt; rm(x, y) &gt; x Error in eval(expr, envir, enclos): 객체 &#39;x&#39;를 찾을 수 없습니다 &gt; y Error in eval(expr, envir, enclos): 객체 &#39;y&#39;를 찾을 수 없습니다 rm() 함수로 변수를 제거하면 변수가 사용하는 메모리는 자유롭게 되며, R이 다른 용도로 이 메모리를 사용할 수 있다. 사실 요즘에는 컴퓨터의 메모리의 용량이 매우 크므로 작은 데이터를 분석할 때는 메모리 사용에 크게 주의를 기울일 필요는 없다. 그러나 데이터가 커지고 분석이 복잡해지면 메모리 사용량이 급격히 늘어날 수 있으므로 필요없는 변수를 적절히 제거해 주는 것이 필요하다. 여기서 주의할 점은 rm()에 의해서 메모리가 자유롭게 되더라도 R이 사용하던 메모리가 운영체제로 바로 반환되지는 않는다는 것이다. 이를 처리하려면 gc() 함수를 이용하여 garbage collection을 하도록 해야 한다. 그러나 사실 R은 주기적으로 garbage collection을 하므로 특별한 이유가 없으면 이를 별도로 수행할 필요는 없다. 2.5.9 변수 목록 확인하기: ls() ls() 함수를 이용하면 현재 환경에서 정의되어진 모든 변수의 이름을 출력해 준다. 반면 rm() 함수는 list 인자에 변수의 이름을 주면 해당 변수를 메모리에서 제거한다. 따라서 아래와 같은 방식을 이용하면 현재 환경에 정의되어 있는 모든 변수를 제거할 수 있다. &gt; a &lt;- 5 &gt; b &lt;- 7 &gt; ls() [1] &quot;a&quot; &quot;b&quot; &quot;hook_output&quot; &gt; #rm(list=ls()) &gt; #ls() 2.5.10 변수를 할당하는 또 다른 방법: assign() assign() 함수로도 변수의 할당은 할 수 있다. 대부분의 경우는 assign() 함수를 이용하는 것보다는 앞서 설명한 할당 연산자를 이용하여 변수에 값을 할당하는 것이 편리하고 이해하기도 쉽다. 그러나 가끔 많은 변수를 자동적으로 생성해야 하는 경우나 데이터베이스에서 변수의 이름을 읽어들여와 값을 할당하는 등의 경우에는 assign() 함수를 이용하는 것이 필요하다. assign() 함수는 첫번째 인수로 변수의 이름을 문자열로 받고, 두번째 인수로 변수에 할당할 값을 받는다. &gt; x1 Error in eval(expr, envir, enclos): 객체 &#39;x1&#39;를 찾을 수 없습니다 &gt; assign(&quot;x1&quot;, 5) &gt; x1 [1] 5 &gt; assign(&quot;x1&quot;, x1 + 3) &gt; x1 [1] 8 위의 예에서 x1이라는 변수가 없었는데, assign() 함수에 의해 x1 변수가 할당되었음을 볼 수 있다. 주의할 점은 보통의 할당문에서는 변수가 문자열과 구분되도록 따옴표 없이 사용되나, assign() 함수에서는 변수의 이름을 문자열로 따옴표와 함께 표현해 주어야 한다는 것이다. 2.6 함수를 이용한 연산 R의 기본 기능에는 다양한 함수가 포함되어 있다. 사용자도 자신만의 함수를 만들 수 있다. 함수는 인수로 입력 값을 받은 후 함수의 처리 결과를 반환한다. 함수에 어떤 값을 입력해야 하고 어떤 값을 반환받을 수 있는지는 함수마다 다르다. 2.6.1 함수 호출 하기 R에서 함수를 이용하려면 다음의 형태로 함수를 호출하여야 한다. &gt; 함수이름(인수1, 인수2, ...) 함수 출력 값 아래는 제곱근을 구하는 sqrt() 함수의 예이다. 함수의 입력 인수(arguments)로는 4가 주어졌고 제곱근을 구하는 함수는 입력된 4를 가지고 결과인 2를 반환하고 있다. 함수는 연산자와 함께 사용될 수 있고 함수의 결과가 다시 다른 함수의 입력 인수가 될 수도 있다. &gt; sqrt(4) [1] 2 &gt; (sqrt(9) + 2) / 4 [1] 1.25 &gt; sin( (sqrt(9) + 2)/ 4 ) [1] 0.9489846 Table 2.1: 수학 관련 주요 함수 수학 함수 설명 ceiling(x) x의 값을 정수로 올림 floor(x) x의 값을 정수로 내림 trunc(x) x의 값의 소수점 자리를 버림 round(x) x의 값을 반올림 round(x, digits=n) x의 값을 소수점 n자리에서 반올림 sqrt(x) x의 제곱근 exp(x) x의 지수함수 값 log(x) 자연대수를 밑으로 하는 로그 값 log(x, base=a) a를 밑으로 하는 로그 값 sin(x), cos(x), tan(x) x의 삼각함수의 값 factorial(n) n! choose(n,k) n 개 중 k를 뽑는 조합의 수 표 2.1은 R에 내장되어 있는 수학 관련 주요 함수를 보여준다. 2.6.2 실수를 정수로 변환하는 함수 다음은 함수를 이용하여 숫자에 대한 올림, 내림, 버림, 반올림 등을 수행한 예이다. &gt; a &lt;- 3.141593 &gt; ceiling(a) # 올림 [1] 4 &gt; floor(a) # 내림 [1] 3 &gt; trunc(a) # 버림 [1] 3 &gt; round(a) # 반올림 [1] 3 &gt; round(a, digits=2) # 반올림의 소수점 자릿수 지정 [1] 3.14 2.6.3 순열과 조합 함수 다음은 순열(factorial)과 조합(combination)의 값을 구한 결과이다. 30에 대한 순열 값은 매우 커서 공학 형식으로 숫자가 표시된다. 이를 일반적인 형식으로 표시하기 위해서 format() 함수를 이용하였다. &gt; factorial(5) # 5! [1] 120 &gt; factorial(30) # 30! = 2.652529 * 10^32 [1] 2.652529e+32 &gt; format(factorial(30), scientific = FALSE) # 지수표현 대신 일반적인 숫자로 표현 [1] &quot;265252859812191032188804700045312&quot; &gt; choose(5, 2) # 5 개의 요소에서 2 개를 조합하는 경우의 수 [1] 10 &gt; choose(45, 6) # 로또의 경우의 수: 45 개의 공에서 6 개를 공을 조합하는 경우의 수 [1] 8145060 Python 등의 언어를 사용해본 독자는 더하기 연산으로 문자열을 연결하는 것에 익숙할 것이다. R의 기본 기능은 이러한 문자열 연산을 지원하지 않는다. 사실 Python에서도 숫자의 더하기와 문자의 더하기는 전혀 다른 의미를 갖는다. 10 + 10은 20을 결과로 출력하지만, “10” + “10”은 문자열의 연결인 “1010”을 결과로 준다.↩︎ "],
["ch-R-Data-Structure.html", "Chapter 3 R 데이터 구조 3.1 벡터 3.2 행렬과 배열 3.3 리스트 3.4 데이터 프레임", " Chapter 3 R 데이터 구조 R은 숫자, 문자열, 논리값이라는 데이터 형식을 가지고 더 복잡한 데이터 구조를 만든다. R에서 흔히 사용되는 4가지 데이터 구조는 벡터, 행렬, 리스트, 데이터 프레임이다. 그림 3.1은 벡터, 행렬/배열, 리스트, 데이터 프레임의 구조를 도식화한 것이다. 벡터는 동일한 형식의 데이터를 1차원으로 연결한 데이터 구조이고, 행렬은 동일한 형식의 데이터를 2차원으로, 배열을 2차원 이상의 차원으로 데이터를 연결한 데이터 구조이다. 반면 리스트와 데이터 프레임은 서로 다은 형식의 데이터를 하나의 데이터 구조로 묶어 준다. Figure 3.1: R 데이터의 기본 구조 이 책에서는 R 데이터 구조에 대한 문법 중에 벡터와 데이터 프레임에 대한 기본적인 문법만 다루고 나머지 부분은 생략하고자 한다. 통계분석에서 가장 중요한 데이터 구조가 데이터 프레임이므로 데이터 프레임에 대한 기본적인 이해가 필요하고, 데이터 프레임의 각 열은 벡터이므로 벡터에 대한 이해도 필요하기 때문이다. R의 데이터 구조에 대한 좀 더 전반적인 이해를 원하는 독자는 졸저 R 프로그래밍을 참조하기 바란다. 3.1 벡터 벡터는 R의 통계 분석에서 가장 중요한 데이터 형식이다. 다른 범용의 프로그래밍 언어와는 다르게 R은 벡터 단위의 연산 및 조작을 지원함으로써 통계 데이터 분석에 매우 편리한 이점을 제공한다. 3.1.1 벡터는 동일 형식 데이터의 나열 벡터는 50명 학생들의 키 데이터 (162.1, 175.8, 183.2, …), 50명 학생들의 성별 데이터 (“여”, “남”, “남”, …)처럼 한가지 형식의 데이터를 나열한 것이다. 여기서 형식이란 1과 2 등의 숫자 형식, “여”와 “남” 등의 문자열 형식, TRUE와 FALSE의 논리값 형식을 의미한다. 숫자 벡터에는 숫자 데이터만 나열되고, 문자열 벡터나 논리값 벡터에는 각각 문자열과 논리값만이 나열된다. 벡터가 포함하고 있는 데이터의 개수를 벡터의 길이 또는 크기라고 한다. 따라서 50 명 학생의 키 데이터는 길이가 50인 벡터가 된다. 사실 R은 벡터가 아닌 숫자, 문자, 논리값은 없다. 10이라는 숫자 하나도 사실은 길이가 1인 숫자 벡터이고, 문자열도 논리값도 길이가 1인 문자 벡터와 논리 벡터일 뿐이다. 벡터를 사용하기 위해서는 벡터를 생성하는 법, 벡터를 연산하는 법, 벡터의 일부분을 필터링/인덱싱하는 법을 배워야 한다. 3.1.2 벡터를 생성하는 법 3.1.2.1 c() 함수를 이용한 벡터의 생성 벡터는 기본적으로 벡터의 요소를 c() 함수로 연결하여 만든다. 다음 예처럼 1, 3, 5라는 숫자를 차례로 연결하여 벡터를 만들고 싶으면, 다음처럼 c() 함수에 각 요소를 차례로 인수로 기술한다. &gt; x &lt;- c(1, 3, 5) &gt; x [1] 1 3 5 다음 예처럼 문자열이나 논리값을 연결하여 문자열 벡터와 논리값 벡터를 만들 수 있다. 아울러 연결하고자 하는 요소의 개수는 원하는 만큼 나열할 수 있다. &gt; y &lt;- c(&quot;빨강&quot;, &quot;파랑&quot;, &quot;노랑&quot;) &gt; y [1] &quot;빨강&quot; &quot;파랑&quot; &quot;노랑&quot; &gt; z &lt;- c(TRUE, FALSE, FALSE, TRUE) &gt; z [1] TRUE FALSE FALSE TRUE c() 함수는 요소를 하나씩 연결하는 것뿐만 아니라 여러 개의 요소를 가진 벡터들을 연결하여 더 큰 벡터를 만들 수도 있다. &gt; w &lt;- c(7, 9); w [1] 7 9 &gt; c(x, w) [1] 1 3 5 7 9 &gt; c(w, x) [1] 7 9 1 3 5 앞의 예는 세 요소를 가진 벡터 x와 두 요소를 가진 벡터 w를 연결하여 새로운 벡터를 만든 예이다. 나열 순서에 따라 새롭게 만들어지는 벡터의 요소들의 위치가 어떻게 되는지 확인해 보라. 이론적으로 말하자면 사실 앞서 본 숫자 1, 3, 5도 요소가 하나인 벡터이고, 요소가 하나짜리 벡터를 연결하여 x와 w라는 벡터를 만든 것이다. 3.1.2.2 수열 패턴을 이용한 숫자 벡터의 생성 1에서부터 10까지의 자연수로 이루어진 벡터를 만든다고 해 보자. 앞에서 배운 c() 함수를 이용하여 이 벡터를 만드려면 10개의 요소를 일일이 나열하여야 하므로 매우 번거로운 작업이 된다. 이럴 때 사용할 수 있는 것이 수열 패턴을 이용하여 숫자 벡터를 만드는 것이다. : 연산자를 이용하면 다음처럼 하나씩 증가하거나 감소하는 수열 패턴으로 벡터를 만들 수 있다. : 연산자 앞에 기술된 숫자를 시작으로 하여 뒤에 기술된 숫자가 앞에 기술된 숫자보다 크면 하나씩 증가하는, 작으면 감소하는 패턴을 만든다. &gt; 1:10 [1] 1 2 3 4 5 6 7 8 9 10 &gt; 20:11 [1] 20 19 18 17 16 15 14 13 12 11 seq() 함수를 사용하면 수열의 시작점(from)과 종료점(to), 그리고 수열이 얼만큼 증가 또는 감소될 지(by)를 지정할 수 있다. &gt; seq(from=1, to=10, by=2) [1] 1 3 5 7 9 &gt; seq(from=11, to=100, by=11) [1] 11 22 33 44 55 66 77 88 99 &gt; seq(from=100, to=0, by=-15) [1] 100 85 70 55 40 25 10 3.1.2.3 비교 연산을 이용한 논리값 벡터 만들기 논리값 벡터는 자주 비교 연산을 이용하여 만들어진다. 예를 들어 중간고사 점수가 80점 이상인 학생은 TRUE, 나머지 학생은 FALSE로 하는 논리값 벡터를 만든다고 해 보자. 다음처럼 학생의 점수가 scores라는 변수에 들어가 있다고 해 보자. 그러면 다음처럼 비교 연산을 이용하여 간단히 논리값 벡터를 만들 수 있다. &gt; scores &lt;- c(75, 92, 88, 60, 80) &gt; scores [1] 75 92 88 60 80 &gt; scores &gt;= 80 [1] FALSE TRUE TRUE FALSE TRUE &gt; scores &gt; 80 [1] FALSE TRUE TRUE FALSE FALSE 논리값 연산을 이용하면 더 복잡한 조건의 요소만 TRUE가 되도록 논리값 벡터를 만들 수 있다. 다음은 80점 이상이지만 90점 미만인 학생만 TRUE로 만든 예이다. &gt; scores &gt;= 80 &amp; scores &lt; 90 [1] FALSE FALSE TRUE FALSE TRUE 그런데 앞의 비교 연산의 왼편에 있는 scores는 다섯 개의 요소를 가지고 있지만, 오른편에는 오직 하나의 숫자로만 이루어진 벡터가 있다. R은 연산을 해야 하는 벡터의 길이가 다르면 요소의 재활용이라는 원리를 사용하여 연산을 수행한다. 그러면 벡터의 연산이 어떻게 이루어지는지 살펴보자. 3.1.3 벡터의 연산 R에서 벡터에 대한 연산은 대부분 동일 위치의 요소끼리 그리고 요소의 재활용이라는 두 가지 원칙에 따라 수행된다. 동일 위치의 요소끼리라는 원칙은 동일한 길이의 두 벡터가 연산이 이루어지면 같은 위치의 요소끼리 연산이 이루어 진다는 것이다. &gt; a &lt;- 1:6; a [1] 1 2 3 4 5 6 &gt; b &lt;- seq(from=10, to=60, by=10); b [1] 10 20 30 40 50 60 &gt; a + b [1] 11 22 33 44 55 66 &gt; a * b [1] 10 40 90 160 250 360 숫자 벡터뿐 아니라 문자열, 논리값 벡터도 같은 원칙에 의해서 연산이 이루어진다. &gt; x [1] 1 3 5 &gt; y [1] &quot;빨강&quot; &quot;파랑&quot; &quot;노랑&quot; &gt; paste(y, x, sep=&quot;-&quot;) [1] &quot;빨강-1&quot; &quot;파랑-3&quot; &quot;노랑-5&quot; &gt; c(TRUE, FALSE, TRUE) &amp; c(FALSE, FALSE, TRUE) [1] FALSE FALSE TRUE &gt; c(TRUE, FALSE, TRUE) | c(FALSE, FALSE, TRUE) [1] TRUE FALSE TRUE 길이가 같은 벡터는 동일한 위치의 요소끼리 연산이 된다면, 길이가 다른 벡터의 연산을 어떻게 이루어질까? 연산을 해야할 벡터의 길이가 서로 다르면 짧은 길이의 벡터의 요소가 반복적으로 요소 재활용이 되어 길이가 긴 벡터의 길이만큼 늘어난 후, 동일한 위치의 요소끼리 연산이 수행된다. &gt; a + c(10, 20) [1] 11 22 13 24 15 26 &gt; a * c(1, 10, 100) [1] 1 20 300 4 50 600 &gt; a * 1000 [1] 1000 2000 3000 4000 5000 6000 마지막 연산은 길이가 1인 벡터가 a에 맞추어 6 개의 요소가 되도록 반복되어 재활용된 후 같은 위치의 요소끼리 연산이 이루어졌다. 마찬가지로 앞서 학생들의 점수를 비교 연산한 예에서도 오른편의 숫자가 학생들의 점수의 개수만큼 반복되어 비교가 이루어졌다. 3.1.4 벡터의 필터링/인덱싱 데이터를 분석하다 보면, 데이터의 특정 요소만 추출하여 분석해 보고 싶을 때가 있다. 40세 이상의 고객만 추출하여 분석한다든지, 남자 학생에 대해서만 별도의 분석을 하는 경우가 그러한 예라고 할 수 있다. 이렇게 데이터에서 특정 부분만 추출하여 새로운 데이터를 만드는 작업을 필터링(filtering)이라고 한다. 벡터 필터링은 특정 벡터에서 특정 요소만을 추출하는 것을 의미한다. R에서 벡터 필터링은 인덱스 벡터를 이용하여 수행된다. 여기서 인덱스란 벡터에서 특정 요소의 위치를 의미한다. 예를 들어 5개의 요소로 구성된 벡터에서 두번째 요소를 추출하려면 두번째라는 위치가 그 요소의 인덱스가 된다. 그런데 어떤 벡터에서 추출하고자 하는 요소가 여러 개일 수도 있다. 이 경우 추출해야할 위치를 여러 개 나열해야 하고, 이렇게 나열한 요소의 위치 정보를 인덱스 벡터라고 한다. 물론 하나의 요소만 추출하고자 한다면 인덱스 벡터는 길이가 1이 될 것이다. 벡터 필터링을 하려면 다음처럼 벡터의 이름 다음에 인덱스 벡터를 대괄호 안에 기술하면 된다. &gt; vector[index_vector] 인덱스 벡터는 자연수 벡터, 음의 정수 벡터, 논리값 벡터, 이름 벡터의 네 가지 형태를 가질 수 있다. 이 중에서 자연수, 음의 정수, 논리값 인덱스 벡터를 각각 살펴보도록 하자. 자연수 인덱스 벡터는 벡터에서 뽑아내고자 하는 요소의 위치를 자연수로 기술하는 인덱스 벡터이다. 다음은 학생들의 성적 벡터인 scores 벡터에서 각 위치의 데이터를 뽑아내는 예이다. &gt; scores[2] [1] 92 &gt; scores[2:4] [1] 92 88 60 &gt; scores[c(1, 4)] [1] 75 60 음의 정수 인덱스 벡터는 벡터에서 어떤 위치의 요소만 제외하고 뽑을 때 사용하는 인덱스 벡터이다. &gt; scores[-2] [1] 75 88 60 80 &gt; scores[-c(1, 4)] [1] 92 88 80 인덱스 벡터에서 가장 자주 사용되고 유용한 인덱스 벡터가 논리값 인덱스 벡터이다. 논리값 인덱스 벡터는 뽑아내고자 하는 위치의 요소에는 TRUE, 뽑지 않은 위치의 요소에는 FALSE를 기술한다. &gt; scores[c(TRUE, FALSE, TRUE, TRUE, FALSE)] [1] 75 88 60 자연수 인덱스 벡터나 음의 정수 인덱스 벡터와는 달리 논리값 인덱스 벡터는 벡터의 모든 요소에 TRUE나 FALSE가 기술되어야 한다. 만약 논리 인덱스 벡터의 길이가 원래 벡터보다 짧으면 다음처럼 벡터의 요소의 재활용이 인덱스 벡터에 적용된다. &gt; scores[c(TRUE, FALSE)] [1] 75 88 80 논리값 인덱스 벡터가 자주 사용되는 이유는 특정 조건에 맞는 요소만 벡터에서 뽑아낼 수 있기 때문이다. 다음은 학생 점수가 80점 이상인 학생의 데이터와 80점 이상이고 90점 미만인 학생의 데이터를 뽑아낸 예이다. &gt; scores[scores &gt;= 80] [1] 92 88 80 &gt; scores[scores &gt;= 80 &amp; scores &lt; 90] [1] 88 80 위의 예에서는 데이터가 5 개밖에 없으므로 자연수 인덱스 벡터를 사용하여도 필터링이 가능하다. 그러나 데이터가 수백, 수천개가 된다고 상상해 보자. 그러면 논리값 인덱스 벡터가 얼마나 유용한 도구인지 쉽게 이해할 수 있을 것이다. 이것으로 벡터에 대한 기본적인 사항을 다루었다. 그렇지만 이는 매우 기본적인 사항이므로 좀 더 복잡한 벡터의 조작이 필요한 독자는 R 프로그래밍의 R 벡터 장을 참조하기 바란다. 마찬가지로 행렬/배열, 리스트, 데이터 프레임 구조에 대해서도 생성, 인덱싱, 연산의 방법을 배워야 한다. 3.2 행렬과 배열 벡터보다 조금 더 복잡한 데이터 구조가 행렬과 배열이다. 행렬과 배열은 벡터처럼 모든 요소가 동일한 데이터의 타입을 가져야 한다. 3.2.1 행렬과 배열은 다차원적 데이터 구조 지금까지 배운 벡터는 일차원적인 데이터 구조였다. 벡터의 길이가 50이라면 벡터의 각 요소의 위치는 \\(1, 2, \\ldots, 50\\)까지 하나의 숫자로 특정할 수 있다. 반면 행렬과 배열은 다차원적인 데이터 구조이다. 행렬은 2차원적 데이터 구조로 행과 열로 구성된다. 행렬의 각 요소의 위치는 어떤 행과 어떤 열에 포함되는지를 나타내는 두 개의 숫자로 특정할 수 있다. 배열은 행렬을 일반화한 것으로 다차원적인 데이터 구조이다. 예로 3차원 배열은 세 개의 숫자에 의해 데이터의 위치를 특정할 수 있다. 3.2.2 행렬과 배열의 필요성 행렬의 예로 다음을 고려해 보자. 어떤 강의의 수강생을 성별, 학년의 두 가지 기준으로 분류한다고 해 보자. 그러면 표 3.1 같은 형식으로 데이터를 정리할 수 있을 것이다. 이와 같이 두 범주형 변수에 대해 관측도수를 요약한 표를 교차표(cross table) 또는 분할표라고 한다. Table 3.1: 어떤 과목의 수강생 분할표 1학년 2학년 3학년 4학년 남 0 5 7 5 여 2 4 8 2 표 3.1 같은 데이터는 일차원적인 벡터 형태로 데이터를 저장하면 각 데이터 요소가 어떤 의미를 갖는지 파악하기가 쉽지 않다. 이러한 경우에는 2차원으로 구성된 행렬을 이용하는 것이 좋다. 통계분석에서 행렬은 주로 시계열 데이터를 다루거나, 빈도표나 분할표(교차표) 등의 표로된 기술통계량을 기술할 때 주로 사용된다. 이 책에서는 시계열 데이터는 다루지 않을 것이며, 빈도표와 분할표도 R 함수의 결과로서만 출력하고 이를 다시 조작하거나 연산하는 작업을 하지 않을 것이므로 행렬에 대한 문법은 더 이상 다루지 않을 것이다. 행렬과 배열에 대한 생성, 연산, 필터링 등의 자세한 문법은 R 프로그래밍의 R 행렬 장을 참조하기 바란다. 3.3 리스트 벡터나 행렬은 포함되는 요소가 모두 같은 타입이어야 했다. 리스트는 숫자와 문자 등 다른 타입의 데이터를 결합시키는 데이터 구조이다. 리스트는 여러 형식의 데이터를 담아두는 데이터 구조로, 리스트의 요소들은 같은 모드나 타입일 필요가 없을 뿐 아니라 리스트 안에 또 다른 리스트를 포함할 수 있다. 따라서 리스트는 컴퓨터의 폴더 구조처럼 계층적 구조를 가질 수 있다. 리스트의 구조는 사용자가 자유롭게 지정할 수 있으므로 매우 복잡한 형식의 데이터를 다룰 수 있다. 3.3.1 리스트 이해의 중요성 실제 데이터 분석을 수행할 때 사용자가 리스트를 직접적으로 생성하는 경우는 그리 많지 않다. 그러나 리스트를 이해하는 것은 매우 중요한데 그 이유는 다음과 같다. 첫째, 데이터 분석에서 가장 중요한 데이터 구조는 데이터 프레임이다. 그리고 데이터 프레임은 리스트를 기반으로 하고 있다. 따라서 데이터 프레임의 근간이 되는 리스트에 대해 명확하게 이해하는 것이 데이터를 효율적으로 조작하는 데 도움이 된다. 둘째, 통계 및 데이터 마이닝을 위해 사용하는 다양한 R의 함수는 복잡한 분석의 결과를 리스트 타입으로 제공하는 경우가 많다. 따라서 데이터 분석의 결과를 효과적으로 이용하기 위해서는 리스트 구조를 이해할 필요가 있다. 리스트에 대한 생성, 연산, 필터링 등의 자세한 문법은 R 프로그래밍의 R 리스트 장을 참조하기 바란다. 3.4 데이터 프레임 데이터 프레임이란 데이터 구조를 다룬다. 보통 다른 통계 소프트웨어에서 데이터 분석의 기본 단위인 데이터 집합 또는 데이터 행렬이라고 불리는 것이다. 데이터 프레임은 행렬을 일반화한 것으로 생각하면 이해하기 쉽다. 행렬에 속한 데이터는 모두 같은 타입인데 반해, 데이터 프레임은 각 열마다 각기 다른 타입의 데이터를 가질 수 있다. 데이터 프레임에는 한 열은 숫자 타입의 데이터가, 다른 한 열은 문자 타입의 데이터가 각각 들어갈 수 있다. Table 3.2: 과목 수강생 데이터 일부 major grade gender class mid final hw scores 16 ME 2-year F class-1 46 45 88.30 63.79 17 ME 2-year F class-1 53 68 82.80 71.14 18 ME 2-year F class-1 46 53 84.30 64.99 19 ME 2-year F class-1 83 91 88.30 88.69 20 ME 2-year M class-1 55 56 91.00 70.59 21 ME 2-year F class-1 74 81 91.00 83.79 22 ME 2-year F class-1 36 41 91.00 60.39 23 Others 3-year F class-2 92 88 83.26 88.31 24 Others 4-year F class-2 75 67 91.33 80.00 25 Others 3-year M class-2 88 65 84.00 81.10 26 ME 4-year M class-2 88 81 88.59 87.28 27 ME 3-year M class-2 93 95 88.96 93.09 28 ME 3-year M class-2 90 88 90.59 90.58 29 ME 2-year M class-2 36 52 81.19 60.09 30 ME 3-year M class-2 41 67 81.56 66.87 31 ME 2-year M class-2 49 50 82.67 64.50 32 ME 2-year M class-2 67 61 88.96 75.09 33 ME 2-year M class-2 41 60 88.96 66.99 34 ME 2-year M class-2 84 74 74.15 79.64 35 ME 2-year M class-2 38 45 76.22 57.77 표 3.2처럼 한 강의를 수강하고 있는 학생의 데이터에서 중간고사, 기말고사 같이 숫자 데이터도 있지만, 학생 이름과 성별처럼 문자 데이터도 있다. 데이터의 형태는 다르지만 한 학생에 대한 정보를 얻기 위해서는 숫자, 문자, 논리 값을 포함한 데이터를 다룰 수 있어야 한다. 이 경우에 사용할 수 있는 데이터 구조가 데이터 프레임이라 할 수 있다. 본질적으로 데이터 프레임은 data.frame 클래스인 리스트로서, 각 요소가 벡터이고 벡터의 길이가 같은 리스트이다. 3.4.1 데이터 프레임의 열(변수)은 벡터이다. 표 3.2처럼 한 강의를 수강하고 있는 학생의 데이터에서 각 열은 벡터이다. 성별(gender)은 문자열 벡터이고, 중간고사(mid) 점수는 숫자 벡터이다. 만약 학생 별로 이번 수강이 재수강 여부인지를 TRUE/FALSE로 나타낸다면 논리값 벡터가 될 것이다. 데이터 프레임의 각 열을 선택하는 방법은 다음과 같다. 데이터프레임_이름$열_이름 다음은 iris라는 Fisher의 붓꽃 데이터이다. 이 데이터는 150개의 붓꽃에 대한 꽃받침(sepal)과 꽃입(petal)의 길이(length)와 두께(width)와 품종(Species)에 대한 열을 가지고 있다. 다음은 head() 함수로 iris의 앞의 6줄만 확인한 후, 꽃받침의 길이(Sepal.Length) 열을 뽑아낸 결과이다. &gt; head(iris) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5.0 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa &gt; iris$Sepal.Length [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 [145] 6.7 6.7 6.3 6.5 6.2 5.9 데이터 프레임의 열은 벡터라고 했다. 그러므로 $ 연산자로 데이터 프레임의 열을 지정하면, 데이터 프레임의 열을 벡터처럼 사용할 수 있다. 앞에서 본 꽃받침의 길이(iris$Sepal.Length)는 숫자 벡터이다. 그러므로 숫자 벡터에 사용되는 평균과 표준편차를 구하는 함수인 mean()과 sd() 함수를 사용할 수 있고, 숫자 벡터에서 배운 연산, 필터링을 사용할 수 있다. &gt; mean(iris$Sepal.Length) [1] 5.843333 &gt; sd(iris$Sepal.Length) [1] 0.8280661 &gt; iris$Sepal.Length[iris$Sepal.Length &gt; 7] [1] 7.1 7.6 7.3 7.2 7.7 7.7 7.7 7.2 7.2 7.4 7.9 7.7 한 가지 주의할 점은, 앞으로 볼 R의 통계분석을 위한 함수들이 사용자의 편의를 위해 분석에 사용할 데이터 프레임을 data 또는 .data 등의 인수로 지정한 후, 이 데이터 프레임의 열을 함수 안에서 지정할 때 $ 연산자를 사용하지 않고 열의 이름만 지정하여 사용하는 경우가 있다. 예를 들어 xtab() 함수는 빈도표나 교차표를 구할 때 사용하는데, 다음처럼 data 인수에 데이터 프레임을 지정한 후 빈도를 구할 열을 $ 연산자 없이 지정하고 있다. &gt; xtabs(~ Species, data=iris) Species setosa versicolor virginica 50 50 50 그러나 이처럼 data 등의 인수로 함수에서 사용할 데이터 프레임을 명확하게 지정한 경우가 아니면, 데이터 프레임의 열은 항상 $ 연산자를 사용하여 지정해야 한다. 다음은 table() 함수를 사용하여 동일한 빈도표를 구한 경우이다. &gt; table(iris$Species) setosa versicolor virginica 50 50 50 다시 말해 데이터 프레임의 열은 $ 연산자로 지정하는 것이 원래의 문법이나, 데이터 프레임을 사용하는 많은 함수들이 사용자의 편의를 위해 data 인수에 이미 데이터 프레임을 지정했으면, 열의 이름만으로 열을 지정하도록 편의를 제공하고 있지만, 그렇지 않은 함수들도 있으므로 표준적인 문법과 편의 기능을 서로 혼동하지 말아야 한다는 것이다. 3.4.2 데이터 프레임의 문법과 조작 데이터 프레임의 생성, 연산, 필터링하는 R의 기본 문법을 더 자세히 알고자 하면, R 프로그래밍의 R 데이터 프레임 장을 참조하기 바란다. 앞서 언급하였듯이 데이터 프레임은 데이터 분석에서 가장 중요한 데이터 구조이다. 그렇기 때문에 분석에 적절하게 데이터 프레임을 변형하거나 결합하는 작업이 데이터 전처리에서 빈번하게 이루어진다. 이 때 데이터 프레임의 생성, 연산, 필터링하는 R의 기본 문법을 사용하여도 데이터 프레임을 조작할 수 있지만, 최근의 추세는 Hadley Wickham 등이 제공하고 있는 tidyverse 패키지를 사용하는 경우가 많다. 그러므로 4 장에서 tidyverse 패키지를 사용하여 데이터 프레임을 조작하는 방법을 배우도록 하자. "],
["ch-dataTransformation.html", "Chapter 4 데이터 변환 4.1 정돈 데이터 (tidy data) 4.2 tidyverse 패키지 4.3 dplyr 패키지와 정돈 데이터의 변환 4.4 filter()로 행 선택하기 4.5 arrange()로 행 정렬하기 4.6 select()를 이용하여 변수 이름으로 열 선택하기 4.7 mutate()로 새로운 변수 만들기 4.8 summarize()로 변수 요약하기 4.9 group_by()로 그룹 별로 요약하기 4.10 %&gt;% 파이프 연산자", " Chapter 4 데이터 변환 이 장에서는 정돈 형식의 데이터를 변환하는 방법을 배운다. 4.1 정돈 데이터 (tidy data) 4.1.1 정돈 데이터 형식의 조건 정돈 데이터란 다음 조건을 만족하는 데이터 행렬(R에서는 데이터 프레임)의 형식을 의미한다. 데이터 행렬의 각 행과 관측(대상)(observations)은 일대일의 관계이다. 데이터 행렬의 각 열과 변수(variables)는 일대일의 관계이다. 측정값(values)은 각 셀과 일대일의 관계이다. 정돈 데이터 형식을 그림 4.1처럼 표현할 수 있다. Figure 4.1: 정돈 데이터 4.1.2 비정돈 데이터 형식 현실에서 만나는 많은 데이터가 정돈 데이터 형식이지만, 그렇지 않은 데이터도 자주 볼 수 있다. 그림 4.2의 왼쪽 데이터는 어떤 가상의 감염병에 대해 세 나라의 발생 사례를 월별로 정리한 데이터이다. 이 데이터는 감염 사례라는 변수와 관련된 데이터가 3개의 열에 흩어져 있으므로 비정돈 형식이다. 월별, 년도별 매출처럼 시계열 데이터는 종종 이런 형식으로 데이터가 표현된다. 이러한 방식의 표현은 데이터를 매우 압축적인 방식으로 표현할 수 있고 같은 시간대의 데이터를 비교하기 쉬운 장점이 있다. 그림 4.2의 오른쪽 데이터는 왼쪽 데이터를 정돈 형식으로 변환한 결과이다. 이러한 변환을 하는 방법에 대해서는 6.3 절에서 다룰 것이다. Figure 4.2: 비정돈 데이터 4.1.3 정돈 데이터를 사용하는 이유 그림 4.2를 보면 정돈 형식 데이터가 오히려 비효율적인 방식으로 보이며, 데이터를 한 눈에 비교하기도 어려워 보인다. 그럼에도 정돈 형식의 데이터를 사용하는 이유는 표준화된 데이터 변환 작업을 하기 위해서이다. 한 행이 하나의 관측 대상을, 한 열이 하나의 변수를, 한 셀이 한 값을 나타낸다는 가정이 성립하면, 데이터 변환이나 데이터를 이용한 그래픽 작업을 데이터의 내용에 무관하게 항상 일정한 형식으로 수행할 수 있다. 4.2 tidyverse 패키지 tidyverse 패키지는 정돈 데이터 패러다임을 따른 R 패키지들을 한번에 설치하고 적재할 수 있도록 돕는 패키지이다. 4.2.1 tidyverse 패키지 설치 tidyverse 패키지를 설치하려면 다음 명령을 실행하면 된다. 패키지의 이름은 문자열이므로 따옴표 안에 기술해야 한다. &gt; install.packages(&quot;tidyverse&quot;) 또는 RStudio의 Packages 탭에서 [Install]을 클릭한 후 tidyverse라고 입력을 하면 된다. 패키지 설치는 한 번만 수행하면 된다. 4.2.2 tidyverse 패키지 적재 tidyverse 패키지가 설치되었으면 패키지를 사용할 때마다 네임스페이스를 적재하고 검색 리스트에 패키지를 포함하는 작업이 필요하다.3 다음은 tidyverse 패키지를 적재하는 명령어이다. 이번에는 패키지 이름에 따옴표가 없음에 주의한다. &gt; library(tidyverse) 앞의 명령을 실행하면 정돈 데이터 패러다임을 따르는 여러 개의 패키지가 동시에 적재된다. 그리고 R 기본 패키지와 정돈 데이터 패키지 중에서 이름이 충돌이 나는 것에 대해 보고를 한다. 만약 R 기본 패키지에서 이 함수를 사용하는 경우에는 패키지이름::함수() 형식으로만 사용할 수 있다. 자세한 내용은 R 관련 책을 참조하기 바란다. 4.3 dplyr 패키지와 정돈 데이터의 변환 4.3.1 dplyr 패키지 정돈 데이터의 변환에는 tidyverse 패키지가 포함하고 있는 dplyr 패키지가 이용된다. 앞에서 tidyverse를 적재하였으면 이미 dplyr이 적재되어 있으므로 다시 적재할 필요가 없다. 4.3.2 정돈 데이터 변환의 종류 정돈 데이터의 변환은 크게 5가지 변환 작업이 있다. filter(): 데이터에서 관측(대상)을 측정값을 기준으로 선택한다. arrange(): 관측(대상)을 기준으로 데이터를 정렬한다. select(): 변수이름으로 일부 변수만 데이터에서 선택한다. mutate(): 기존 변수를 사용하여 새로운 변수를 데이터에 추가한다. summarize(): 여러 측정치를 하나의 통계량으로 요약한다. 그리고 위의 작업은 group_by() 함수와 같이 사용되어 전체 데이터에서 작업이 수행되는 것이 아니라 관측(대상)의 그룹별로 수행되도록 조정할 수 있다. 일반적으로 데이터의 변환 작업은 위의 6가지 작업이 여러 차례 순서대로 결합하여 진행된다. 4.3.3 mpg 데이터 이 장에서는 ggplot2() 패키지에서 제공하는 mpg 데이터를 이용하여 정돈 데이터를 변환하는 함수를 설명한다. 다음 명령을 이용하여 mpg 데이터를 출력해 보자. 화면의 크기에 따라 출력되는 내용이 책과는 조금 다를 수 있다. &gt; mpg # A tibble: 234 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto(l… f 18 29 p comp… 2 audi a4 1.8 1999 4 manual… f 21 29 p comp… 3 audi a4 2 2008 4 manual… f 20 31 p comp… 4 audi a4 2 2008 4 auto(a… f 21 30 p comp… 5 audi a4 2.8 1999 6 auto(l… f 16 26 p comp… 6 audi a4 2.8 1999 6 manual… f 18 26 p comp… 7 audi a4 3.1 2008 6 auto(a… f 18 27 p comp… 8 audi a4 quat… 1.8 1999 4 manual… 4 18 26 p comp… 9 audi a4 quat… 1.8 1999 4 auto(l… 4 16 25 p comp… 10 audi a4 quat… 2 2008 4 manual… 4 20 28 p comp… # … with 224 more rows mpg는 1999년과 2008년에 미국 EPA에서 조사하여 발표한 자동차 주요 모델별 연비 데이터이다. 데이터는 234 개의 행이 있으며, 각 행은 다음과 같은 변수로 구성되어 있다. manufacturer: 자동차 제조사 model: 자동차 모델명 displ: 자동차 배기량 year: 제조년도 cyl: 엔진 실린더 수 trans: 자동차 트랜스미션 종류 drv: 자동차 구동 방식. f=전륜구동, r=후륜구동, 4=사륜구동 cty: 도심 연비 (마일/갤론) hwy: 고속도로 연비 (마일/갤론) fl: 연료 종류 class: 자동차 분류 4.4 filter()로 행 선택하기 4.4.1 선택 조건이 하나인 경우 선택 조건이 하나인 경우 다음 형식으로 filter()를 사용한다. filter(데이터프레임, 조건) ’데이터프레임’에는 filter()를 적용할 데이터 프레임을 ’조건’에는 행 선택 조건을 기술한다. ’조건’은 논리값 벡터이어야 한다. 많은 경우 ’조건’은 다음처럼 변수와 어떤 값을 비교연산자로 비교한다. &gt; filter(mpg, manufacturer==&quot;hyundai&quot;) # A tibble: 14 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 1999 4 auto(l… f 18 26 r midsize 2 hyundai sonata 2.4 1999 4 manual… f 18 27 r midsize 3 hyundai sonata 2.4 2008 4 auto(l… f 21 30 r midsize 4 hyundai sonata 2.4 2008 4 manual… f 21 31 r midsize 5 hyundai sonata 2.5 1999 6 auto(l… f 18 26 r midsize 6 hyundai sonata 2.5 1999 6 manual… f 18 26 r midsize 7 hyundai sonata 3.3 2008 6 auto(l… f 19 28 r midsize 8 hyundai tibur… 2 1999 4 auto(l… f 19 26 r subcom… 9 hyundai tibur… 2 1999 4 manual… f 19 29 r subcom… 10 hyundai tibur… 2 2008 4 manual… f 20 28 r subcom… 11 hyundai tibur… 2 2008 4 auto(l… f 20 27 r subcom… 12 hyundai tibur… 2.7 2008 6 auto(l… f 17 24 r subcom… 13 hyundai tibur… 2.7 2008 6 manual… f 16 24 r subcom… 14 hyundai tibur… 2.7 2008 6 manual… f 17 24 r subcom… &gt; filter(mpg, cty &gt; 28) # A tibble: 3 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 volkswagen jetta 1.9 1999 4 manual… f 33 44 d compact 2 volkswagen new be… 1.9 1999 4 manual… f 35 44 d subcom… 3 volkswagen new be… 1.9 1999 4 auto(l… f 29 41 d subcom… &gt; filter(mpg, cty &gt;= 28) # A tibble: 5 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 honda civic 1.6 1999 4 manual… f 28 33 r subcom… 2 toyota corolla 1.8 2008 4 manual… f 28 37 r compact 3 volkswagen jetta 1.9 1999 4 manual… f 33 44 d compact 4 volkswagen new be… 1.9 1999 4 manual… f 35 44 d subcom… 5 volkswagen new be… 1.9 1999 4 auto(l… f 29 41 d subcom… 조건을 서술할 때 자주 틀리는 부분이 등호 기호로 =를 사용하는 것이다. R에서 두 값이 같은지를 비교할 때는 ==를 사용한다. 다음처럼 조건에 사용되는 변수에 대해 연산을 수행한 후에 그 결과를 비교할 수도 있다. &gt; filter(mpg, cty * 2 &gt; 60) # A tibble: 2 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 volkswagen jetta 1.9 1999 4 manual… f 33 44 d compact 2 volkswagen new be… 1.9 1999 4 manual… f 35 44 d subcom… &gt; filter(mpg, sqrt(cty) &lt; 3.2) # A tibble: 5 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 dodge dakota pi… 4.7 2008 8 auto(… 4 9 12 e pick… 2 dodge durango 4… 4.7 2008 8 auto(… 4 9 12 e suv 3 dodge ram 1500 … 4.7 2008 8 auto(… 4 9 12 e pick… 4 dodge ram 1500 … 4.7 2008 8 manua… 4 9 12 e pick… 5 jeep grand che… 4.7 2008 8 auto(… 4 9 12 e suv 4.4.2 여러 조건을 만족하는 행 추출하기 두 개 이상의 조건을 모두 만족하는 행만 뽑아내려면 다음의 문법을 사용한다. filter(데이터프레임, 조건1, 조건2, ..., 조건n) 다음은 현대에서 생산한 차 중 도심 연비가 20 마일 이상인 차만 추출한 결과이다. &gt; filter(mpg, manufacturer==&quot;hyundai&quot;, cty &gt;= 20) # A tibble: 4 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsize 2 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsize 3 hyundai tibur… 2 2008 4 manual(… f 20 28 r subcom… 4 hyundai tibur… 2 2008 4 auto(l4) f 20 27 r subcom… 앞의 조건에서 배기량이 2.4 이상인 차만 추출해 보자. &gt; filter(mpg, manufacturer==&quot;hyundai&quot;, cty &gt;= 20, displ &gt;= 2.4) # A tibble: 2 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsi… 2 hyundai sonata 2.4 2008 4 manual(m… f 21 31 r midsi… 4.4.3 논리 연산자로 복합 조건 만들기 지금까지는 하나의 조건이나 여러 조건을 동시에 만족하는 행을 추출하는 방법을 보았다. 어떤 경우에는 여러 조건 중 하나라도 만족하면 그 행을 추출해야 할 경우가 있다. 이러한 경우에는 @ref(ch:R_Data_Basic) 장에서 배운 논리 연산자를 이용하여 복합 조건을 만들어야 한다. 다음은 OR 연자자인 |를 이용하여 두 조건 중 하나만 만족하여도 행이 추출되도록 하였다. &gt; filter(mpg, model==&quot;sonata&quot; | cty &gt;= 28) # A tibble: 12 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 honda civic 1.6 1999 4 manual… f 28 33 r subco… 2 hyundai sonata 2.4 1999 4 auto(l… f 18 26 r midsi… 3 hyundai sonata 2.4 1999 4 manual… f 18 27 r midsi… 4 hyundai sonata 2.4 2008 4 auto(l… f 21 30 r midsi… 5 hyundai sonata 2.4 2008 4 manual… f 21 31 r midsi… 6 hyundai sonata 2.5 1999 6 auto(l… f 18 26 r midsi… 7 hyundai sonata 2.5 1999 6 manual… f 18 26 r midsi… 8 hyundai sonata 3.3 2008 6 auto(l… f 19 28 r midsi… 9 toyota corolla 1.8 2008 4 manual… f 28 37 r compa… 10 volkswagen jetta 1.9 1999 4 manual… f 33 44 d compa… 11 volkswagen new be… 1.9 1999 4 manual… f 35 44 d subco… 12 volkswagen new be… 1.9 1999 4 auto(l… f 29 41 d subco… 만약 위의 결과에서 2008년도 데이터만 추출하고 싶다면 어떻게 해야 할까? 다음처럼 두 조건식을 사용하여 첫 번째 조건과 두 번째 조건을 모두 만족하는 결과만 추출할 수도 있고, 하나의 조건식에 AND 연산자인 &amp;를 사용하여 복합 조건식을 사용하여 추출할 수도 있다. &gt; filter(mpg, model==&quot;sonata&quot; | cty &gt;= 28, year==2008) # A tibble: 4 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsi… 2 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsi… 3 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsi… 4 toyota corolla 1.8 2008 4 manual(… f 28 37 r compa… &gt; filter(mpg, (model==&quot;sonata&quot; | cty &gt;= 28) &amp; year==2008) # A tibble: 4 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsi… 2 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsi… 3 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsi… 4 toyota corolla 1.8 2008 4 manual(… f 28 37 r compa… 단, 복합 조건식에서 AND 연산이 OR 연산보다 우선순위가 있으므로 괄호를 사용하여 연산의 순서가 제대로 되도록 하여야 한다. 괄호가 없으면 AND가 수행된 후 OR가 수행되어 모든 소타나 자동차의 결과가 추출되었음을 볼 수 있다. &gt; filter(mpg, model==&quot;sonata&quot; | cty &gt;= 28 &amp; year==2008) # A tibble: 8 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 1999 4 auto(l4) f 18 26 r midsi… 2 hyundai sonata 2.4 1999 4 manual(… f 18 27 r midsi… 3 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsi… 4 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsi… 5 hyundai sonata 2.5 1999 6 auto(l4) f 18 26 r midsi… 6 hyundai sonata 2.5 1999 6 manual(… f 18 26 r midsi… 7 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsi… 8 toyota corolla 1.8 2008 4 manual(… f 28 37 r compa… 4.4.4 결측치가 있는 경우 R에서는 데이터에 결측치가 있을 때 이를 NA 값으로 표시한다. 예를 들어 5 명의 학생의 키 데이터가 있는 데 마지막 학생의 데이터를 얻지 못하였다면, 그 학생의 데이터는 NA로 값을 입력한다. is.na() 함수를 이용하면 결측치의 포함 여부를 확인할 수 있다. na.omit() 함수를 이용하면 결측치를 제외한 벡터를 만들 수 있다. &gt; z &lt;- c(1:3, NA) &gt; z [1] 1 2 3 NA &gt; is.na(z) [1] FALSE FALSE FALSE TRUE &gt; na.omit(z) [1] 1 2 3 attr(,&quot;na.action&quot;) [1] 4 attr(,&quot;class&quot;) [1] &quot;omit&quot; 결측치가 있으면 sum()이나 mean() 같은 함수들의 결과는 NA가 출력된다. 결측치를 제외하고 이들 함수를 사용하려면 함수 인수에 na.rm=TRUE를 덧붙여야 한다. 그러면 결측치를 제외하고 결과를 계산하게 된다. &gt; sum(z) [1] NA &gt; sum(z, na.rm=TRUE) [1] 6 조건에 사용되는 변수에 결측치가 있는 경우에 결측치가 있는 행을 추출하려면 is.na() 함수를 이용하여야 한다. 4.5 arrange()로 행 정렬하기 arrange()는 다음 문법을 사용하여 행을 정렬한다. arrange(데이터프레임, 첫번째 정렬 기준 변수, 두번째 정렬 기준 변수, ....) filter()와 마찬가지로 첫 번재 인수로 정렬할 데이터 프레임을 전달 받는다. 그리고 두번재 인수부터 정렬의 기준이 되는 변수를 차례로 기술한다. 첫 번째 기준 변수의 값이 같으면, 두 번째 기준 변수를, 두 번째 기준 변수의 값까지 같으면 그 다음 변수를 기준으로 차례로 순서를 결정하여 정렬을 수행한다. 다음은 2008년도 현대의 자동차 모델만 filter()론 선택하여 a라는 변수에 저장한 후, 이 데이터에 대하여 여러 조건으로 정렬을 수행해본 예이다. &gt; a &lt;- filter(mpg, manufacturer == &quot;hyundai&quot;, year == 2008) &gt; a # A tibble: 8 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsize 2 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsize 3 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsize 4 hyundai tibur… 2 2008 4 manual(… f 20 28 r subcom… 5 hyundai tibur… 2 2008 4 auto(l4) f 20 27 r subcom… 6 hyundai tibur… 2.7 2008 6 auto(l4) f 17 24 r subcom… 7 hyundai tibur… 2.7 2008 6 manual(… f 16 24 r subcom… 8 hyundai tibur… 2.7 2008 6 manual(… f 17 24 r subcom… &gt; arrange(a, cyl) # A tibble: 8 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsize 2 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsize 3 hyundai tibur… 2 2008 4 manual(… f 20 28 r subcom… 4 hyundai tibur… 2 2008 4 auto(l4) f 20 27 r subcom… 5 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsize 6 hyundai tibur… 2.7 2008 6 auto(l4) f 17 24 r subcom… 7 hyundai tibur… 2.7 2008 6 manual(… f 16 24 r subcom… 8 hyundai tibur… 2.7 2008 6 manual(… f 17 24 r subcom… &gt; arrange(a, cyl, cty) # A tibble: 8 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai tibur… 2 2008 4 manual(… f 20 28 r subcom… 2 hyundai tibur… 2 2008 4 auto(l4) f 20 27 r subcom… 3 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsize 4 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsize 5 hyundai tibur… 2.7 2008 6 manual(… f 16 24 r subcom… 6 hyundai tibur… 2.7 2008 6 auto(l4) f 17 24 r subcom… 7 hyundai tibur… 2.7 2008 6 manual(… f 17 24 r subcom… 8 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsize &gt; arrange(a, model, trans) # A tibble: 8 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsize 2 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsize 3 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsize 4 hyundai tibur… 2 2008 4 auto(l4) f 20 27 r subcom… 5 hyundai tibur… 2.7 2008 6 auto(l4) f 17 24 r subcom… 6 hyundai tibur… 2 2008 4 manual(… f 20 28 r subcom… 7 hyundai tibur… 2.7 2008 6 manual(… f 17 24 r subcom… 8 hyundai tibur… 2.7 2008 6 manual(… f 16 24 r subcom… 4.5.1 desc()를 이용하여 내림차순으로 정렬하기 앞의 예에서 arrange()는 수치 변수는 올림차순으로 문자 변수는 알파벳 순으로 정렬하는 것을 볼 수 있다. 만약 위의 예에서 내림차순으로, 또는 알파벳 역순으로 정렬을 하고 싶으면 어떻게 하여야 할까? dplyr 패키지는 desc()를 이용하면 된다. &gt; arrange(a, desc(cyl)) # A tibble: 8 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsize 2 hyundai tibur… 2.7 2008 6 auto(l4) f 17 24 r subcom… 3 hyundai tibur… 2.7 2008 6 manual(… f 16 24 r subcom… 4 hyundai tibur… 2.7 2008 6 manual(… f 17 24 r subcom… 5 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsize 6 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsize 7 hyundai tibur… 2 2008 4 manual(… f 20 28 r subcom… 8 hyundai tibur… 2 2008 4 auto(l4) f 20 27 r subcom… &gt; arrange(a, desc(cyl), cty) # A tibble: 8 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai tibur… 2.7 2008 6 manual(… f 16 24 r subcom… 2 hyundai tibur… 2.7 2008 6 auto(l4) f 17 24 r subcom… 3 hyundai tibur… 2.7 2008 6 manual(… f 17 24 r subcom… 4 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsize 5 hyundai tibur… 2 2008 4 manual(… f 20 28 r subcom… 6 hyundai tibur… 2 2008 4 auto(l4) f 20 27 r subcom… 7 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsize 8 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsize &gt; arrange(a, model, desc(trans)) # A tibble: 8 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 manual(… f 21 31 r midsize 2 hyundai sonata 3.3 2008 6 auto(l5) f 19 28 r midsize 3 hyundai sonata 2.4 2008 4 auto(l4) f 21 30 r midsize 4 hyundai tibur… 2.7 2008 6 manual(… f 16 24 r subcom… 5 hyundai tibur… 2 2008 4 manual(… f 20 28 r subcom… 6 hyundai tibur… 2.7 2008 6 manual(… f 17 24 r subcom… 7 hyundai tibur… 2 2008 4 auto(l4) f 20 27 r subcom… 8 hyundai tibur… 2.7 2008 6 auto(l4) f 17 24 r subcom… desc()가 적용된 변수만 내림차순을 기준으로 정렬을 하는 것을 볼 수 있다. 4.6 select()를 이용하여 변수 이름으로 열 선택하기 4.6.1 변수 이름을 나열하여 선택하기 select() 함수는 다음처럼 변수 이름을 일일이 나열하여 원하는 열을 선택할 수 있다. R의 기본 문법을 알고 있는 사람들은 데이터 프레임의 인덱싱에서처럼 문자열로 이름을 나열하는 것이 아니라 변수를 사용하듯 따옴표 없이 이름을 나열하는 것에 주의한다. select(데이터프레임, 변수이름1, 변수이름 2, ....) &gt; select(a, model, year, cty, hwy) # A tibble: 8 x 4 model year cty hwy &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 sonata 2008 21 30 2 sonata 2008 21 31 3 sonata 2008 19 28 4 tiburon 2008 20 28 5 tiburon 2008 20 27 6 tiburon 2008 17 24 7 tiburon 2008 16 24 8 tiburon 2008 17 24 4.6.2 변수 이름으로 변수 범위를 선택하기 select() 함수는 다음처럼 변수 이름으로 선택할 변수의 범위를 지정할 수 있다. select(데이터프레임, 범위시작_변수이름:범위종료_변수이름, ...) &gt; select(a, model:trans) # A tibble: 8 x 5 model displ year cyl trans &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; 1 sonata 2.4 2008 4 auto(l4) 2 sonata 2.4 2008 4 manual(m5) 3 sonata 3.3 2008 6 auto(l5) 4 tiburon 2 2008 4 manual(m5) 5 tiburon 2 2008 4 auto(l4) 6 tiburon 2.7 2008 6 auto(l4) 7 tiburon 2.7 2008 6 manual(m6) 8 tiburon 2.7 2008 6 manual(m5) &gt; select(a, model:trans, cty:hwy) # A tibble: 8 x 7 model displ year cyl trans cty hwy &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; 1 sonata 2.4 2008 4 auto(l4) 21 30 2 sonata 2.4 2008 4 manual(m5) 21 31 3 sonata 3.3 2008 6 auto(l5) 19 28 4 tiburon 2 2008 4 manual(m5) 20 28 5 tiburon 2 2008 4 auto(l4) 20 27 6 tiburon 2.7 2008 6 auto(l4) 17 24 7 tiburon 2.7 2008 6 manual(m6) 16 24 8 tiburon 2.7 2008 6 manual(m5) 17 24 반대로 다음처럼 변수 이름으로 선택하지 않을 변수의 범위를 지정할 수 있다. select(데이터프레임, -(범위시작_변수이름:범위종료_변수이름), ...) &gt; select(a, -(model:trans)) # A tibble: 8 x 6 manufacturer drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai f 21 30 r midsize 2 hyundai f 21 31 r midsize 3 hyundai f 19 28 r midsize 4 hyundai f 20 28 r subcompact 5 hyundai f 20 27 r subcompact 6 hyundai f 17 24 r subcompact 7 hyundai f 16 24 r subcompact 8 hyundai f 17 24 r subcompact &gt; select(a, -(model:trans), -manufacturer) # A tibble: 8 x 5 drv cty hwy fl class &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 f 21 30 r midsize 2 f 21 31 r midsize 3 f 19 28 r midsize 4 f 20 28 r subcompact 5 f 20 27 r subcompact 6 f 17 24 r subcompact 7 f 16 24 r subcompact 8 f 17 24 r subcompact 4.6.3 변수 이름을 매칭하여 선택하기 dplyr 패키지는 다양한 형태로 변수를 선택할 수 있도록 다음의 변수 이름 매칭 함수를 제공한다. starts_with(\"abs\"): abc로 이름이 시작하는 모든 변수 ends_with(\"abs\"): abc로 이름이 끝나는 모든 변수 contains(\"abs\"): abc를 이름에 포함하고 있는 모든 변수 matches(\"(.)\\\\1\"): 정규 표현식을 만족하는 이름을 가진 모든 변수 num_range(\"x\", 1:3): “x1”, “x2”, “x3”이라는 이름의 변수 &gt; select(a, starts_with(&quot;c&quot;)) # A tibble: 8 x 3 cyl cty class &lt;int&gt; &lt;int&gt; &lt;chr&gt; 1 4 21 midsize 2 4 21 midsize 3 6 19 midsize 4 4 20 subcompact 5 4 20 subcompact 6 6 17 subcompact 7 6 16 subcompact 8 6 17 subcompact 4.6.4 변수 이름 바꾸기 select() 함수에서 변수 이름을 지정할 때, (새로운 변수 이름)=(기존 변수 이름) 형식으로 지정하면 변수의 이름을 바꿀 수 있다. &gt; select(a, model, city=cty, highway=hwy) # A tibble: 8 x 3 model city highway &lt;chr&gt; &lt;int&gt; &lt;int&gt; 1 sonata 21 30 2 sonata 21 31 3 sonata 19 28 4 tiburon 20 28 5 tiburon 20 27 6 tiburon 17 24 7 tiburon 16 24 8 tiburon 17 24 만약 전체 데이터를 유지한 상태에서 변수 이름만 변경하려면, rename() 함수를 이용한다. 문법은 select()와 같다. &gt; rename(a, city=cty, highway=hwy) # A tibble: 8 x 11 manufacturer model displ year cyl trans drv city highway fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 hyundai sonata 2.4 2008 4 auto(l… f 21 30 r midsi… 2 hyundai sonata 2.4 2008 4 manual… f 21 31 r midsi… 3 hyundai sonata 3.3 2008 6 auto(l… f 19 28 r midsi… 4 hyundai tibur… 2 2008 4 manual… f 20 28 r subco… 5 hyundai tibur… 2 2008 4 auto(l… f 20 27 r subco… 6 hyundai tibur… 2.7 2008 6 auto(l… f 17 24 r subco… 7 hyundai tibur… 2.7 2008 6 manual… f 16 24 r subco… 8 hyundai tibur… 2.7 2008 6 manual… f 17 24 r subco… 4.6.5 변수 순서 바꾸기 select() 함수는 나열된 변수의 순서에 따라 새롭게 만들어진 데이터 프레임의 변수의 순서를 조정한다. &gt; select(a, cty, hwy) # A tibble: 8 x 2 cty hwy &lt;int&gt; &lt;int&gt; 1 21 30 2 21 31 3 19 28 4 20 28 5 20 27 6 17 24 7 16 24 8 17 24 &gt; select(a, hwy, cty) # A tibble: 8 x 2 hwy cty &lt;int&gt; &lt;int&gt; 1 30 21 2 31 21 3 28 19 4 28 20 5 27 20 6 24 17 7 24 16 8 24 17 이러한 성질과 everything() 함수를 이용하면 변수의 순서를 쉽게 바꿀 수 있다. everything()은 이미 선택된 변수를 제외한 나머지 변수를 의미한다. &gt; select(a, cty, hwy, everything()) # A tibble: 8 x 11 cty hwy manufacturer model displ year cyl trans drv fl class &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 21 30 hyundai sonata 2.4 2008 4 auto(l4) f r midsize 2 21 31 hyundai sonata 2.4 2008 4 manual(… f r midsize 3 19 28 hyundai sonata 3.3 2008 6 auto(l5) f r midsize 4 20 28 hyundai tibur… 2 2008 4 manual(… f r subcom… 5 20 27 hyundai tibur… 2 2008 4 auto(l4) f r subcom… 6 17 24 hyundai tibur… 2.7 2008 6 auto(l4) f r subcom… 7 16 24 hyundai tibur… 2.7 2008 6 manual(… f r subcom… 8 17 24 hyundai tibur… 2.7 2008 6 manual(… f r subcom… 4.7 mutate()로 새로운 변수 만들기 mutate()는 기존 변수를 이용하여 새로운 변수를 만들어 데이터 프레임의 가장 마지막 열로 추가한다. mutate(데이터프레임, 새로운_변수=기존_변수_연산식, ....) 다음은 도심 연비와 고속도로 연비의 합과, 평균, 그리고 고속도로 대비 도심 연비의 비율(%)을 계산하여 새로운 열을 만든 예이다. &gt; b &lt;- select(a, -(cyl:drv), -(fl:class)) &gt; b # A tibble: 8 x 6 manufacturer model displ year cty hwy &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 hyundai sonata 2.4 2008 21 30 2 hyundai sonata 2.4 2008 21 31 3 hyundai sonata 3.3 2008 19 28 4 hyundai tiburon 2 2008 20 28 5 hyundai tiburon 2 2008 20 27 6 hyundai tiburon 2.7 2008 17 24 7 hyundai tiburon 2.7 2008 16 24 8 hyundai tiburon 2.7 2008 17 24 &gt; mutate(b, sum=cty + hwy) # A tibble: 8 x 7 manufacturer model displ year cty hwy sum &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 hyundai sonata 2.4 2008 21 30 51 2 hyundai sonata 2.4 2008 21 31 52 3 hyundai sonata 3.3 2008 19 28 47 4 hyundai tiburon 2 2008 20 28 48 5 hyundai tiburon 2 2008 20 27 47 6 hyundai tiburon 2.7 2008 17 24 41 7 hyundai tiburon 2.7 2008 16 24 40 8 hyundai tiburon 2.7 2008 17 24 41 &gt; mutate(b, + sum=cty + hwy, + mean=(cty + hwy) / 2, + ratio= cty / hwy * 100) # A tibble: 8 x 9 manufacturer model displ year cty hwy sum mean ratio &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 hyundai sonata 2.4 2008 21 30 51 25.5 70 2 hyundai sonata 2.4 2008 21 31 52 26 67.7 3 hyundai sonata 3.3 2008 19 28 47 23.5 67.9 4 hyundai tiburon 2 2008 20 28 48 24 71.4 5 hyundai tiburon 2 2008 20 27 47 23.5 74.1 6 hyundai tiburon 2.7 2008 17 24 41 20.5 70.8 7 hyundai tiburon 2.7 2008 16 24 40 20 66.7 8 hyundai tiburon 2.7 2008 17 24 41 20.5 70.8 4.7.1 transmute()로 새로운 변수만 남기기 만약 새롭게 만들어진 변수만 데이터에 남기려면 mutate() 대신 transmute()를 사용한다. 문법은 두 함수가 동일하다. &gt; transmute(b, + sum=cty + hwy, + mean=(cty + hwy) / 2, + ratio= cty / hwy * 100) # A tibble: 8 x 3 sum mean ratio &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 51 25.5 70 2 52 26 67.7 3 47 23.5 67.9 4 48 24 71.4 5 47 23.5 74.1 6 41 20.5 70.8 7 40 20 66.7 8 41 20.5 70.8 4.7.2 새로운 변수를 만들 때 사용할 수 있는 함수들 새로운 변수를 생성할 때, 기존 변수와 관련된 수치, 논리, 문자열 연산을 수행할 수 있다. 다음처럼 제조사와 모델을 하나로 합쳐서 새로운 변수를 만들수도 있고, 배기량이 3 이상인지 여부를 나타내는 변수도 만들 수 있다. &gt; mutate(b, newName=paste(manufacturer, model, sep=&quot;-&quot;), dis3=displ &gt;= 3) # A tibble: 8 x 8 manufacturer model displ year cty hwy newName dis3 &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; 1 hyundai sonata 2.4 2008 21 30 hyundai-sonata FALSE 2 hyundai sonata 2.4 2008 21 31 hyundai-sonata FALSE 3 hyundai sonata 3.3 2008 19 28 hyundai-sonata TRUE 4 hyundai tiburon 2 2008 20 28 hyundai-tiburon FALSE 5 hyundai tiburon 2 2008 20 27 hyundai-tiburon FALSE 6 hyundai tiburon 2.7 2008 17 24 hyundai-tiburon FALSE 7 hyundai tiburon 2.7 2008 16 24 hyundai-tiburon FALSE 8 hyundai tiburon 2.7 2008 17 24 hyundai-tiburon FALSE 아울러 다음 함수가 새로운 변수를 만들 때 자주 사용된다. lead(): 기존 변수를 한 행, 또는 여러 행 빠르게 시작하는 변수 rag(): 기존 변수를 한 행, 또는 여러 행 늦게 시작하는 변수 cumsum(), cummean(): 누적 합과 평균 min_rank(): 가장 작은 것부터 차례대로 크기 순서로 등수를 매기는 함수. desc() 함수를 변수에 적용한 후 등수를 매기면 가장 큰 것부터 순서를 매길 수 있다. dense_rank(), percent_rank(), cume_dist(), ntile() 등도 사용될 수 있다. 자세한 내용은 도움말을 참조하기 바란다. &gt; mutate(b, cty_rank=min_rank(cty), hwy_rank=min_rank(desc(hwy)), desc_hwy=desc(hwy)) # A tibble: 8 x 9 manufacturer model displ year cty hwy cty_rank hwy_rank desc_hwy &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 hyundai sonata 2.4 2008 21 30 7 2 -30 2 hyundai sonata 2.4 2008 21 31 7 1 -31 3 hyundai sonata 3.3 2008 19 28 4 3 -28 4 hyundai tiburon 2 2008 20 28 5 3 -28 5 hyundai tiburon 2 2008 20 27 5 5 -27 6 hyundai tiburon 2.7 2008 17 24 2 6 -24 7 hyundai tiburon 2.7 2008 16 24 1 6 -24 8 hyundai tiburon 2.7 2008 17 24 2 6 -24 4.8 summarize()로 변수 요약하기 summarize(데이터프레임, 요약변수이름=요약함수(변수), ....) summarize() 함수는 변수의 모든 값을 하나의 값으로 요약하는 함수를 이용하여 변수를 요약한다. 대표적인 요약 함수는 다음과 같다. n(): 변수의 크기를 구한다. sum(): 수치 변수의 합을 구한다. mean(): 수치 변수의 균을 구한다. median(): 수치 변수의 중위수를 구한다. sd(): 수치 변수의 표준편차를 구한다. var(): 수치 변수의 분산을 구한다. min(): 수치 변수의 최소값을 구한다. max(): 수치 변수의 최대값을 구한다. quantile(변수, probs): 수치 변수의probs` 분위수를 구한다. 다음은 도심 연비의 데이터 수, 평균, 중위수, 최소값, 최대값을 구한 결과이다. &gt; summarize(b, count=n(), mean=mean(cty), med=median(cty), min=min(cty), max=max(cty)) # A tibble: 1 x 5 count mean med min max &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; 1 8 18.9 19.5 16 21 4.9 group_by()로 그룹 별로 요약하기 group_by(데이터프레임, 그룹기준변수1, 그룹기준변수2, ...) group_by() 함수는 기준이 되는 변수의 구분되는 값에 따라 데이터를 그룹화한다. 그룹화된 결과를 summarize() 함수에 전달하면 그룹별로 요약된 결과를 출력한다. &gt; byModel &lt;- group_by(b, model) &gt; summarize(byModel, count=n(), mean=mean(cty), sd=sd(cty)) `summarise()` ungrouping output (override with `.groups` argument) # A tibble: 2 x 4 model count mean sd &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 sonata 3 20.3 1.15 2 tiburon 5 18 1.87 변수를 여러 개를 조합하여 그룹화를 할 수도 있다. &gt; byModel &lt;- group_by(a, model, cyl) &gt; summarize(byModel, count=n(), mean=mean(cty)) `summarise()` regrouping output by &#39;model&#39; (override with `.groups` argument) # A tibble: 4 x 4 # Groups: model [2] model cyl count mean &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 sonata 4 2 21 2 sonata 6 1 19 3 tiburon 4 2 20 4 tiburon 6 3 16.7 4.10 %&gt;% 파이프 연산자 4.10.1 여러 단계를 거쳐 데이터를 변환할 때 mpg 데이터에서 조사 연도와 모델 별로 데이터 수와 도심 연비의 평균을 구한 후, 평균이 22 이상인 모델로 이루어진 행을 추출하려고 한다. 이를 수행하려면 다음처럼 변수를 이용하여 결과를 차례로 전달하거나, 함수를 결합하여 한 문장에 사용하여야 한다. &gt; byModel &lt;- group_by(mpg, model, year) &gt; meanCty &lt;- summarize(byModel, count=n(), mean=mean(cty)) `summarise()` regrouping output by &#39;model&#39; (override with `.groups` argument) &gt; filter(meanCty, mean &gt;= 22) # A tibble: 5 x 4 # Groups: model [3] model year count mean &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 civic 1999 5 24.8 2 civic 2008 4 24 3 corolla 1999 3 24.7 4 corolla 2008 2 27 5 new beetle 1999 4 26 &gt; filter(summarize(group_by(mpg, model, year), count=n(), mean=mean(cty)), mean &gt;= 22) `summarise()` regrouping output by &#39;model&#39; (override with `.groups` argument) # A tibble: 5 x 4 # Groups: model [3] model year count mean &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 civic 1999 5 24.8 2 civic 2008 4 24 3 corolla 1999 3 24.7 4 corolla 2008 2 27 5 new beetle 1999 4 26 전자는 불피요하게 중간 결과를 저장할 변수를 만들어야 하고, 후자는 복잡하여 이 명령이 무엇을 하는 명령어인지 쉽게 파악하기 힘들다. 또한 중첩된 괄호 때문에 오류가 발생하기 쉽다. 4.10.2 파이프 연산자 파이프 연산자는 데이터 변환이 여러 단계를 거칠 때 불필요한 변수의 생성 없이도 함수 간에 중간 데이터를 전달할 수 있게 해 준다. 파이프 연산자는 앞의 함수의 결과를 뒤 함수의 첫 번째 인수로 전달해 준다. 파이프 연산자를 사용할 때는 그러므로 첫 번째 인수는 생략하여 기술한다. 다음은 앞의 예와 동일한 예를 파이프 연산자를 사용하여 수행한 결과이다. &gt; mpg %&gt;% group_by(model, year) %&gt;% + summarize(count=n(), mean=mean(cty)) %&gt;% + filter(mean &gt;= 22) `summarise()` regrouping output by &#39;model&#39; (override with `.groups` argument) # A tibble: 5 x 4 # Groups: model [3] model year count mean &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 civic 1999 5 24.8 2 civic 2008 4 24 3 corolla 1999 3 24.7 4 corolla 2008 2 27 5 new beetle 1999 4 26 불필요하게 데이터를 기술하는 부분이 사라져서 각 단계에서 수행하는 작업이 무엇인지 명확하게 들어나고 불필요한 중간 변수를 만들지 않아도 되므로 파이프 연산자는 매우 편리하다. 그런데 파이프 연산자를 사용하려면 앞의 함수의 결과가 뒤의 함수의 첫 인수로 사용하기 적절한 형태이어야 한다. dplyr 패키지의 주요 함수들은 정돈 데이터 형식으로 데이터의 결과를 반환하고, 첫 인수가 정돈 데이터 형식의 데이터로 간주한다. 파이프 연산자를 사용할 때 주의할 점은 여러 줄로 명령을 기술할 때, 파이프 연산자로 중간 문장이 종료되어야 한다는 것이다. 그래야 아직 문장이 완료되지 않았다는 것을 이해하여 다음 단계의 명령이 입력되기를 기다린다. 다음처럼 기술하면 R은 명령 입력이 중간에 완료된 것으로 보고 잘못된 결과를 출력한다. &gt; b %&gt;% group_by(model) %&gt;% + summarize(count=n(), mean=mean(cty)) + %&gt;% filter(mean &gt;= 20) Error: &lt;text&gt;:3:3: 예기치 않은 SPECIAL입니다 2: summarize(count=n(), mean=mean(cty)) 3: %&gt;% ^ 4.10.3 ungroup() 파이프 연산자를 사용하여 데이터를 전달하다 보면 데이터가 그룹화 된 것을 중간 단계에서 해제하고 싶을 때가 있다. 이 경우에는 ungroup() 명령을 사용한다. &gt; byModel &lt;- b %&gt;% group_by(model) &gt; byModel %&gt;% summarize(count=n()) `summarise()` ungrouping output (override with `.groups` argument) # A tibble: 2 x 2 model count &lt;chr&gt; &lt;int&gt; 1 sonata 3 2 tiburon 5 &gt; byModel %&gt;% ungroup() %&gt;% summarize(count=n()) # A tibble: 1 x 1 count &lt;int&gt; 1 8 반드시 필요한 작업은 아니다. 그렇지만 실행하는 것이 작업할 때 매우 편리하므로 필수적인 작업으로 생각하는 것이 좋다.↩︎ "],
["ch-visualization.html", "Chapter 5 R 데이터 시각화 기초 5.1 ggplot2 패키지 설치하기 5.2 ggplot2 시작하기 5.3 그래프 속성과 데이터 열 매핑하기 (aesthetic mapping) 5.4 ggplot 명령문을 입력할 때 자주 발생하는 문제들 5.5 geom 함수와 그래프 계층 5.6 측면(facets)으로 나누어 그리기 5.7 기타 ggplot2의 문법 요소", " Chapter 5 R 데이터 시각화 기초 데이터 시각화란 데이터를 그래프 등의 시각적 요소로 요약하여 보여주는 것을 의미한다. R에서는 데이터 시각화를 R의 기본 기능에 포함된 graphics 패키지를 사용하여 시각화하는 방법과 ggplot2패키지를 이용하는 방법이 있다. 이 장에서는 ggplot2를 이용하여 데이터를 시각화하는 기본적인 방법을 배운다. 여기서는 통계분석에 필요한 기본적인 그래프를 그리기 위한 기본적인 문법을 소개하는 것이지 ggplot2에 대한 체계적인 설명을 하지 않을 것이다. ggplot2는 자유로운 형식으로 그래프를 그릴 수 있는 그래프 문법을 가지고 있기 때문에, ggplot2에 대한 더 체계적인 이해를 원하는 독자는 졸저 ’R 프로그래밍’의 ggplot2를 이용한 데이터 시각화를 참조하기 바란다. 5.1 ggplot2 패키지 설치하기 R은 패키지란 단위로 R에서 사용할 수 있는 기능을 제공한다. R을 설치하면 base, stat, dataset, graphics 등의 기본 패키지가 자동으로 설치되고, R을 시작할 때마다 이러한 기본 패키지가 자동으로 적대되어 사용될 수 있도록 준비된다. 만약 R에서 기본으로 제공하는 패키지 말고 다른 패키지를 사용하려면 그 패키지를 R에 설치해야 한다. ggplot2 패키지는 기본 기능에 포함되지 않으므로 먼저 설치를 해야 한다. ggplot2 패키지를 설치하려면 다음 명령을 실행하면 된다. 패키지의 이름은 문자열이므로 따옴표 안에 기술해야 한다. &gt; install.packages(&quot;ggplot2&quot;) 또는 RStudio의 우측 하단의 Packages 탭에서 [Install]을 클릭한 후 ggplot2라고 입력을 하면 된다. 패키지 설치는 한 번만 수행하면 된다. 패키지를 사용하려면 메모리에 적재를 하여야 한다. 패키지를 메모리에 적재하는 것은 library() 함수를 사용한다. 이 때 주의할 점은 이미 설치된 패키지를 지정할 때는 따옴표 없이 변수처럼 패키지를 기술해야 한다는 것이다. &gt; library(ggplot2) 패키지의 설치는 한 번만 수행하면 되지만, 패키지를 메모리에 적재하는 작업을 패키지를 사용할 때마다 수행하여야 한다. 한번 메모리에 적재된 패키지는 R 세션이 종료되기 전까지 유지된다. 그러므로 하나의 R 세션에서는 다시 library() 함수로 동일한 패키지를 적재하지 않아도 된다. 그러나 R 세션을 종료하고 다시 시작하였다면, 기본 패키지가 아니면 자동 적재되지 않으므로 사용하기 전에 패키지를 다시 적재하여야 한다. 5.2 ggplot2 시작하기 이 절에서는 ggplot2에서 제공하는 mpg 데이터를 이용하여 ‘배기량이 커지면 연비가 낮아지는가?’ 라는 물음을 그래프를 이용하여 탐색해 보자. mpg는 1999년과 2008년에 미국 EPA에서 조사하여 발표한 자동차 주요 모델별 연비 데이터이다. 다음 명령을 이용하여 mpg 데이터를 출력해 보자. mpg 데이터는 tibble이라는 데이터 프레임의 일종으로, 사용자의 화면의 크기에 따라 출력 내용을 조정한다. 그러므로 화면의 크기에 따라 출력되는 내용이 책과는 조금 다를 수 있다. &gt; mpg # A tibble: 234 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto(l… f 18 29 p comp… 2 audi a4 1.8 1999 4 manual… f 21 29 p comp… 3 audi a4 2 2008 4 manual… f 20 31 p comp… 4 audi a4 2 2008 4 auto(a… f 21 30 p comp… 5 audi a4 2.8 1999 6 auto(l… f 16 26 p comp… 6 audi a4 2.8 1999 6 manual… f 18 26 p comp… 7 audi a4 3.1 2008 6 auto(a… f 18 27 p comp… 8 audi a4 quat… 1.8 1999 4 manual… 4 18 26 p comp… 9 audi a4 quat… 1.8 1999 4 auto(l… 4 16 25 p comp… 10 audi a4 quat… 2 2008 4 manual… 4 20 28 p comp… # … with 224 more rows mpg는 1999년과 2008년에 미국 EPA에서 조사하여 발표한 자동차 주요 모델별 연비 데이터이다. 데이터는 234 개의 행이 있으며, 각 행은 다음과 같은 변수로 구성되어 있다. manufacturer: 자동차 제조사 model: 자동차 모델명 displ: 자동차 배기량 year: 제조년도 cyl: 엔진 실린더 수 trans: 자동차 트랜스미션 종류 drv: 자동차 구동 방식. f=전륜구동, r=후륜구동, 4=사륜구동 cty: 도심 연비 (마일/갤론) hwy: 고속도로 연비 (마일/갤론) fl: 연료 종류 class: 자동차 분류 mpg 데이터에 대한 더 자세한 설명은 콘솔에 다음을 입력하여 R 도움말을 참조하기 바란다. &gt; ?mpg 5.2.1 ggplot2 그래프의 기본 문법 mpg 데이터로부터 배기량과 고속도로 연비의 관계를 살펴보기 위해서 배기량(displ)을 x 축으로, 고속도로 연비(hwy)를 y 축으로 하는 산점도를 그려보자. 산점도에서 배기량이 커짐지면 연비가 줄어드는 경향을 관찰할 수 있다. &gt; ggplot(mpg, aes(x=displ, y=hwy)) + geom_point() 그러면 이 산점도 그린 ggplot2 명령어의 문법을 살펴보자. ggplot2의 명령어는 항상 ggplot() 함수로 시작하고, + 연산자를 사용하여 그래프에 추가될 요소를 덧붙여 나간다. 이렇게 함수를 +로 연결하여 사용하는 방식은 ggplot2 패키지의 독특한 문법으로 대부분의 다른 R 명령어에서는 이러한 방식을 사용하지 않는다. ggplot() 함수는 그래프의 좌표축과 좌표평면을 만드는 함수이다. 그러므로 다음처럼 ggplot() 함수만 사용하고 그래프에 추가할 요소를 지정하지 않으면 좌표축과 좌표평면만 그린다. &gt; ggplot(mpg, aes(x=displ, y=hwy)) ggplot() 함수의 첫번째 인수는 그래프를 그릴 때 사용할 데이터를 지정하고, 두번째 인수는 그래프 속성과 데이터 열의 관계를 지정한다. 그래프 속성과 데이터 열의 관계는 항상 aes() 함수 내에 기술되고, 다음처럼 &lt;그래프 속성&gt;=&lt;데이터 열&gt;의 형식으로 기술된다. ggplot(데이터, aes(속성1=열1, 속성2=열2, ...)) + geom함수() 앞의 산점도에서는 x라는 그래프의 가로축 속성에 mpg 데이터의 배기량 열 displ이 매핑되었고, y라는 그래프의 세로축 속성에 고속도로 연비 열 hwy가 매핑되었다. 다음은 그래프의 가로축에 데이터의 도심 연비 열인 cty을 매핑하여 산점도를 그린 예이다. 도심 연비가 좋은 차가 고속도로 연비도 좋다는 것을 알 수 있다. &gt; ggplot(mpg, aes(x=cty, y=hwy)) + geom_point() ggplot() 함수에 +로 연결되는 geom 함수는 그래프에 그릴 도형을 지정한다. geom_point() 함수는 ggplot() 함수에 정의된 그래프 속성과 열의 관계를 이용하여 그래프에 점(points)이라는 도형을 그린다. ggplot2에는 점을 그리는 geom_point() 함수뿐 아니라 다양한 도형을 그리는 geom 함수들이 있다. 만약 다음처럼 geom_point() 함수가 아니라 geom_smooth() 함수를 연결하면 점이 아니라 데이터의 추세선을 ggplot() 함수에 정의된 그래프 속성과 열의 관계를 이용하여 그래프에 그린다. &gt; ggplot(mpg, aes(x=displ, y=hwy)) + geom_smooth() `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot() 함수에 여러 개의 geom 함수를 연결하여 두 개 이상의 그래픽적 도형을 그래프에 그릴 수 있다. 이 경우 먼저 기술된 geom 함수의 도형이 아래 층에 그려지고 뒤에 기술된 geom 함수의 도형이 윗 층에 그려진다. &gt; ggplot(mpg, aes(x=displ, y=hwy)) + geom_point() + geom_smooth() `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 5.3 그래프 속성과 데이터 열 매핑하기 (aesthetic mapping) 앞의 산점도에서 배기량에 따라 연비가 줄어드는 관계를 조금 벗어나는 관측치들이 있다. 이 예외적인 관측치들이 자동차 종류의 차이 때문에 발생했다, 라고 가설을 세웠다 하자. 이 가설을 확인해 보려면 자동차 종류별로 관측치를 시각화할 필요가 있다. 앞서 본 geom_point() 함수는 ’점’이라는 도형을 좌표평면 상에서 그린다. 점이라는 도형은 x-축의 위치(x)와 y-축의 위치(y)뿐 아니라 색상(color), 모양(shape), 크기(size), 투명도(alpha) 등의 다른 시각적 속성을 가지고 있다. 우리는 이러한 속성 중 하나에 mpg 데이터의 class 열을 대응시켜 자동차 종류 별로 좌표평면에서 시각적으로 구분되는 점으로 표현할 수 있다. 5.3.1 범주형 변수와 색상(color) 속성의 매핑 다음은 관측치의 종류(class)에 따라 점을 서로 다른 색상(color)으로 표현한 예이다. 자동차의 종류에 따라 점이 다른 색상으로 표현되고, 어떤 색상이 어떤 자동차 종류에 대응되었는지에 대한 범례가 자동 생성된다. &gt; ggplot(mpg, aes(x=displ, y=hwy, color=class)) + geom_point() 앞선 그래프에서 이상치로 표현되었던 점들 중 한 점만 제외하고 모두 2seater 자동차의 관측치였음을 알 수 있다. 이 종류의 차는 스포츠카로 배기량에 비해 가벼운 몸체를 가지고 있어 예외적인 연비가 관측된 것으로 보인다. 다음으로 class 열을 shape, size, alpha 등의 속성에 대응시켜 어떤 결과가 나오는지 살펴보자. 5.3.2 범주형 변수와 모양(shape) 속성의 매핑 shape 속성은 점의 모양을 결정한다. 다음은 앞의 산점도를 구동 방식(drv)에 따라 점의 모양이 다르게 표시한 예이다. &gt; ggplot(mpg, aes(x=displ, y=hwy, shape=drv)) + geom_point() 점의 모양과 색상을 하나의 데이터 열에 매핑하여 좀 더 데이터가 뚜렷이 구분되게 그래프를 그리기도 한다. &gt; ggplot(mpg, aes(x=displ, y=hwy, shape=drv, color=drv)) + geom_point() 물론 다음처런 점의 색상과 모양을 각각 데이터의 다른 열에 매핑할 수도 있다. 다음은 점의 색은 자동차의 종류(class)에 모양은 자동차의 구동방식(drv)에 매핑한 결과이다. &gt; ggplot(mpg, aes(x=displ, y=hwy, shape=drv, color=class)) + geom_point() shape을 사용할 때 주의할 점은 shape은 최대 6개의 모양으로만 점을 구분하기 때문에 class 열처럼 6개보 많은 종류가 있는 열에 매핑되면 데이터가 제대로 표시가 되지 않는다. 다음 예처럼 shape 속성에 class 열을 매핑하니 경고가 나타나고 suv 데이터를 표시하지 못한 것을 확인할 수 있다. &gt; ggplot(mpg, aes(x=displ, y=hwy, shape=class)) + geom_point() Warning: The shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate; you have 7. Consider specifying shapes manually if you must have them. Warning: Removed 62 rows containing missing values (geom_point). 5.3.3 연속형 변수와 크기(size), 색상(color), 투명도(alpha) 속성의 매핑 모양(shape) 속성은 소수의 구분되는 값으로 표현되는 범주형 변수를 표현하기 좋다. 데이터의 열이 연속형 변수이면 연속적인 값을 표현하기 좋은 가로축(x), 세로축(y), 크기(size), 투명도(alpha) 등을 이용하는 것이 좋다. 색상(color)은 범주형 변수와 연속형 변수에 모두 매핑될 수 있다. 범주형 변수로 매핑되면 구분되는 색상으로, 연속형 변수로 매핑되면 색상의 그라데이션으로 값을 표시한다. 다음은 도심 연비와 고속도로 연비를 가로축과 세로축으로 하는 그래프에서 점의 크기 속성을 배기량 열에 매핑한 결과이다. 도심 연비와 고속도로 연비가 좋은 차들은 배기량이 작은 차임을 알 수 있다. &gt; ggplot(mpg, aes(x=cty, y=hwy, size=displ)) + geom_point() 다음은 동일한 도심 연비와 고속도로 연비 산점도에서 그래프에서 점의 색상을 배기량 열에 매핑한 결과이다. 범주형 변수가 매핑될 때와는 달리 색상의 연속적인 변화인 그라데이션을 사용하여 배기량을 표현하고 있음을 볼 수 있다. &gt; ggplot(mpg, aes(x=cty, y=hwy, color=displ)) + geom_point() 다음은 동일한 도심 연비와 고속도로 연비 산점도에서 그래프에서 점의 투명도를 실린더 수 열에 매핑한 결과이다. &gt; ggplot(mpg, aes(x=cty, y=hwy, alpha=cyl)) + geom_point() 5.4 ggplot 명령문을 입력할 때 자주 발생하는 문제들 ggplot은 매우 강력한 기능을 가지고 있지만 Excel 등의 GUI 프로그램에만 익숙한 사람은 문자 기반 명령어를 입력하는 것에 어려움을 느낄 수 있다. 컴퓨터는 사람만큼의 유연성을 발휘하지 못하므로 컴퓨터는 자신이 실행해야 할 명령문의 문법에 매우 까다롭게 반응한다. ggplot 명령어 입력시 흔히 발생하는 문제들은 다음과 같다. R 명령문은 대소문자를 구분한다. 따라서 Color와 color는 ggplot에서 서로 다른 인수로 인식되어 오류가 발생한다. ggplot 명령문의 키워드의 철자가 틀리면 다른 키워드로 간주하기 때문에 오류가 발생할 수 있다. 이를 방지하려면 키워드의 일부만 입력한 후 Tab 키를 눌러 자동완성 기능을 사용하여 입력하는 것을 권장한다. ggplot2의 명령문을 입력할 때 여러 함수를 합쳐서 실행하기 위하여 + 연산자를 이용한다.4 ggplot2의 명령문이 길어지면 명령문을 여러 줄로 쓰는 것이 필요한데, 보통 +로 연결되는 곳에서 줄바꿈하는 것이 읽기에 좋다. 이 때 주의할 점이, 줄바꿈을 + 앞이 아니라 뒤에서 해야 한다는 것이다. + 앞에서 하면 R은 명령문의 입력이 완성된 것으로 간주하기 때문이다. 다음은 산점도와 추세선을 한 그래프에 그린 예이다. &gt; ggplot(mpg, aes(x=displ, y=hwy, color=drv)) + geom_point() + geom_smooth() `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 그런데 위의 명령어는 길기 때문에 스크립트 파일을 작성할 때 보기에 불편하다. 이러한 경우에 위의 명령은 다음처럼 세 줄로 나누어 기술될 수 있다. 세 함수를 연결하는 + 위치가 어디에 있는지 살펴보라. (다음 예에서 왼쪽의 &gt; 프롬프트 아래 있는 +는 R 콘솔에서 명령문이 계속되고 있음을 나타내는 표시이다. 이 표시와 사용자가 입력한 +를 혼동하면 안 된다.) &gt; ggplot(mpg, aes(x=displ, y=hwy, color=drv)) + + geom_point() + + geom_smooth() 만약 다음처럼 + 위치가 잘못되면 오류가 발생한다. 왜 이런 결과가 나왔고 오류 메시지의 의미는 무엇일까? R은 Enter로 명령문을 구분한다. 그러므로 첫번째 줄은 +가 없으므로 완벽한 명령문이기 입력된 것으로 간주하고 실행이되어 좌표평면만 그린 것이다. 그러고 나서 두번째 줄을 새로운 명령문으로 실행을 한다. 그런데 다자꼬자 명령문이 +로 시작하니 R은 명령문에 오류가 있다고 판단한다. 왜냐하면 + 연산은 왼편과 오른편에 더할 요소가 있어야 하는데, 왼편의 요소가 기술되지 않았기 때문이다. &gt; ggplot(mpg, aes(x=displ, y=hwy, color=drv)) &gt; + geom_point() Error: Cannot use `+.gg()` with a single argument. Did you accidentally put + on a new line? R 명령문이 조금 길어지면 가장 흔하게 발생하는 실수가 ( )와 \" \"을 짝을 맞추어 제대로 입력하지 못하는 것이다. ggplot2의 명령문도 많은 함수를 사용하다 보니 이를 주의하여야 한다. R 콘솔은 명령이 계속 입력 중이라고 생각하여 &gt;가 아니라 +를 콘솔의 프롬프트로 표시한다. 이 경우 가장 간단한 해결책은 Esc 키를 눌러 명령 입력에서 빠져나와 다시 명령문을 입력하는 것이다. 5.5 geom 함수와 그래프 계층 ggplot2의 장점은 필요에 따라 다양한 형식의 그래프를 쉽게 만들 수 있고, 만들 수 있는 형식도 무궁무진하다는데 있다. 그리고 ggplot2 그래프의 계층적 구조가 이러한 무궁무진한 그래프 형식을 만들어 내는 핵심 요소라 할 수 있다. ggplot2는 좌표평면 위에 여러 계층으로 그래프를 그려서 하나의 좌표평명에 나타냄으로써 복잡한 형식의 그래프를 만들어 낼 수 있다. 다음 그래프는 배기량과 고속도로 연비의 산점도와 추세선을 한 그래프에 그렸다. ggplot() 함수에 지정한 데이터와 그래프 속성과 데이터 열 매핑이 산점도(geom_point())와 추세선(geom_smooth())에 모두 동일하게 정의되었음을 볼 수 있다. &gt; ggplot(mpg, aes(x=displ, y=hwy, color=drv)) + geom_point() + geom_smooth() `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot() 함수가 여러 개의 geom 함수와 연결되면, 하나의 좌표평면에 각각의 geom() 함수의 결과를 층층이 그린다. 이 때, 명령문에 나타나는 순서에 따라 첫번째 나온 geom 함수의 도형이 가장 아래 계층에, 다음에 나오는 geom 함수의 도형이 차례로 그 윗 계층에 그려진다. 5.5.1 geom 함수에서 속성 매핑하기 앞의 배기량과 고속도로 연비의 산점도와 추세선을 그린 그래프에서 추세선을 선 종류(linttype)가 구동 방식(drv)에 따라 다르게 표현하고 싶다. 그런데 산점도는 점이라는 도형으로 그래프를 그리므로 선 종류라는 속성을 가지고 있지 않다. 그리고 산점도도 점의 모양(shape)이 구동 방식에 따라 다르게 표현하고 싶다. 마찬가지로 추세선은 선이라는 도형으로 그래프를 그리므로 점의 모양이라는 속성을 가지고 있지 않다. 이렇듯 여러 geom 함수를 연결하여 그래프를 그릴 때, 특정 geom 함수에만 해당하는 속성은 해당 geom 함수에서 속성과 데이터 열을 매핑하는 것이 좋다. geom 함수도 gglot() 함수처럼 aes() 함수를 이용하여 그래프 속성과 데이터 열을 매핑하는데, 이 매핑이 geom 함수의 첫 번째 인수로 기술된다는 점만 다르다. &gt; ggplot(mpg, aes(x=displ, y=hwy, color=drv)) + + geom_point(aes(shape=drv)) + + geom_smooth(aes(linetype=drv)) `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 따라서 지금까지 배운 내용으로 ggplot2 그래프를 그리는 문법을 확장하면 다음과 같다. ggplot(데이터, aes(공통속성1=열1, 공통속성2=열2, ...)) + geom함수1(aes(geom함수1의 속성1=열1, geom함수1의 속성2=열2, ...)) + geom함수2(aes(geom함수2의 속성1=열1, geom함수2의 속성2=열2, ...)) + .... 확장된 문법으로 맨처음 그린 배기량과 고속도로 연비의 산점도와 추세선 그래프에서, 산점도의 점은 구동 방식에 따라 다른 색으로 표시하지만, 추세선은 모든 데이터에 대하여 하나만 그리려면 어떻게 해야 할까? 답은 다음처럼 색상 속성을 공통 속성으로 ggplot()에 매핑하지 않고 산점도만의 속성 매핑이 되도록 geom_point()에 기술하는 것이다. &gt; ggplot(mpg, aes(x=displ, y=hwy)) + geom_point(aes(color=drv)) + geom_smooth() `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 마찬가지로 추세선을 구동 방식에 따라 다른 색상으로 표시하나 점은 모두 동일한 색으로 표시하고 싶으면 다음처럼 색상이 추세선만의 속성 매핑이 되도록 geom_smooth()에 기술하는 것이다. &gt; ggplot(mpg, aes(x=displ, y=hwy)) + geom_point() + geom_smooth(aes(color=drv)) `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 또한 ggplot() 함수에 그래프를 그릴 때 사용한 데이터와 공통속성 매핑이 되어 있어도, geom 함수에서 데이터와 속성 매핑을 재지정할 수도 있다. 이 경우 각 geom 함수에서 사용하는 data와 mapping은 다음 규칙에 의해 결정된다. geom 함수는 ggplot() 함수에 설정된 data와 mapping을 상속받아 그래프를 그린다. 만약 geom 함수에 data 인수가 설정되면 ggplot() 함수에 설정된 data는 무시된다. 만약 geom 함수에 mapping 인수가 설정되면 ggplot() 함수에 설정된 mapping에 geom 함수에 설정된 mapping이 추가된다. 만약 동일한 도형 속성에 대한 정의가 두 군데 나타나면 geom 함수의 설정이 사용된다. 자세한 내용은 R 프로그래밍의 그래프 계층(layers)과 도형(geoms) 절을 참조하기 바란다. 5.6 측면(facets)으로 나누어 그리기 다음 그래프는 배기량과 고속도로 연비의 관계를 살펴보기 위하여 이 두 변수의 관계를 산점도와 추세선으로 살펴보고 나서, 이 두 변수의 관계가 자동차 종류에 따라 어떻게 달라지는지를 살펴보기 위해 그래프의 색상 속성을 자동차 종류를 나타내는 열에 매핑하여 다르게 표시되도록 하였다. &gt; ggplot(mpg, aes(x=displ, y=hwy)) + geom_point() + geom_smooth() &gt; ggplot(mpg, aes(x=displ, y=hwy, color=drv)) + geom_point() + geom_smooth() 이렇듯 두 변수의 관계를 제삼의 변수 관점에서 세분화하여 살펴보는 방법으로 제삼의 변수를 그래프 속성에 매핑하는 방법 말고도 제삼의 변수의 변수값에 따라 데이터를 별도의 그래프로 나누어 그려보는 방법이 있다. ggplot2에서는 이러한 방식을 측면(facets)으로 나누어 그래프를 그린다고 한다. 5.6.1 facet_wrap()로 일차원 측면 그래프 그리기 다음은 facet_wrap() 함수의 사용법을 보여준다. ~ 은 R에서 수식을 표현할 때 사용되는데, facet_wrap() 함수는 수식을 첫 번재 인수로 입력받는다. facet_wrap() 함수는 ~ 우변에 서술된 변수의 변수값 별로 데이터를 나누어 그래프를 각각 그린다. 이 때 측면(facets)을 지정하는데 사용되는 변수는 범주형 데이터이어야 한다. facet_wrap()은 측면 그래프가 많아지면 줄바꿈하여 그래프를 표시한다. ncol이나 ncol을 설정하면 그래프의 행과 열의 수를 지정하여 줄바꿈 처리를 제어할 수 있다. &gt; ggplot(mpg, aes(x=displ, y=hwy)) + geom_point() + + facet_wrap(~class, nrow = 2) 측면으로 나누어 그려진 그래프는 서로 비교가 용이하도록 동일한 좌표축으로 그려진다. 측면 그래프의 상단에는 어떤 측면의 데이터의 그래프인지를 보여준다. 맨 처음 측면 그래프는 2seater 측면에서 배기량과 고속도로 연비의 산점도를 보여주고, 맨 마지막 측면 그래프는 SUV 측면에서 배기량과 고속도로 연비의 산점도를 보여준다. 두 개 이상의 변수를 조합하여 측면 그래프을 만드려면 다음처럼 수식의 우변에 두 개의 변수를 +로 연결하여 기술하면 된다. 다음은 구동 방식(drv)와 조사 년도(year)의 값에 따라 그래프를 나누어 그린 예이다. 역시 모든 그래프의 좌표축은 동일하고 그래프 상단에 어떤 측면의 그래프인지를 표시하고 있는데 윗줄에 표시된 내용은 구동 방식의 값이고 아랫줄은 조사년도의 값이다. 따라서 첫 번째 측면 그래프는 4륜 구동이고 1999년도 조사한 데이터 측면에서 배기량과 고속도로 연비의 산점도를 보여준다. &gt; ggplot(mpg, aes(x=displ, y=hwy)) + geom_point() + + facet_wrap(~drv + year, nrow = 2) 5.6.2 facet_grid()로 이차원 측면 그래프 그리기 그래프를 두 변수의 측면에서 나누어 그릴 때는 face_wrap() 보다는 facet_grid()를 사용하는 것이 좋다. facet_grid()도 수식을 첫 번재 인수로 입력 받는데, 수식의 좌변과 우변에 측면으로 나누는데 사용할 변수를 지정할 수 있다. 수식의 좌변에 기술된 변수를 기준으로 측면 그래프를 행으로 배열하고, 우변에 기술된 변수를 기준으로 측면 그래프를 열로 배열한다. 다음 그래프는 행은 구동 방식으로, 열은 실린더 수를 기준으로 나누어 측면 그래프를 그린 예이다. 그러므로 두 번째 행-세 번째 열의 그래프는 전륜 구동(f)이고 실린더가 6자동차의 산점도를 나타낸다. &gt; ggplot(mpg, aes(x=displ, y=hwy)) + geom_point() + + facet_grid(drv~cyl) facet_wrap() 함수와 마찬가지로 수식의 좌변과 우변에 +로 하나 이상의 변수를 지정할 수도 있다. &gt; ggplot(mpg, aes(x=displ, y=hwy)) + geom_point() + + facet_grid(drv+year~cyl) 5.7 기타 ggplot2의 문법 요소 ggplot2에는 지금까지 설명한 문법 요소 외에도 통계 변환(stat), 위치 조정(position), 스케일 변환(scale), 좌표축 변환(coord), 테마(theme) 등의 요소가 있다. ggplot2를 사용하여 복잡한 시각화를 수행하려면 이러한 문법 요소에 대한 체계적 이해와 습득이 필요하다. 그러나 이 책은 데이터 시각화 전반을 소개하는 것이 목적이 아니기 때문에, 통계데이터 분석을 위한 그래프를 그릴 때 이러한 문법 요소가 필요하면 그 요소를 단편적으로 설명할 예정이다. 그러므로 좀 더 ggplot2 그래프에 대한 체계적인 이해를 원하는 독자는 R 프로그래밍의 ggplot2를 이용한 데이터 시각화를 참조하기 바란다. 이 절의 나머지 부분에서는 나머지 문법 요소 중 그래프의 외양을 변경하는 매우 간단한 한 가지 문법 요소만 살펴보도록 한다. 5.7.1 그래프 레이블을 조정하기 ggplot2 패키지의 labs() 함수는 그래프의 제목, 좌표축 이름, 범례의 이름을 쉽게 바꿀 수 있게 해준다. 다음은 mpg 데이터의 배기량과 고속도로 연비의 산점도를 자동차 종류 별로 다른 색상으로 그린 예이다. 그런데 ggplot2에서는 기본적으로 좌표축 레이블과 색상의 범례 레이블로, 좌표축과 색상에 매핑된 열의 이름을 사용한다. 그리고 그래프에 제목은 달지 않는다. &gt; ggplot(mpg, aes(x=displ, y=hwy, color=class)) + geom_point() 만약 자동으로 부여된 레이블이 마음에 들지 않으면 이를 labs() 함수로 변경할 수 있다. 위 그래프에서 다음처럼 범례 이름, 축의 이름 한글로 바꾸고, 그래프의 제목도 달아 보자. &gt; ggplot(mpg, aes(x=displ, y=hwy, color=class)) + geom_point() + + labs(title=&quot;배기량과 고속도로 연비 산점도&quot;, + x=&quot;배기량(리터)&quot;, y=&quot;고속도로 연비&quot;, color=&quot;자동차 종류&quot;) labs() 함수는 ggplot2 그래프에 + 연산으로 결합하여 사용되면, 그래픽 속성 매핑에 사용된 x, y, color 인수에 사용할 이름을 지정하면 된다. 그래프의 제목을 지정하려면 title이라는 인수를 사용한다. 함수를 +로 결합시키는 것은 ggplot2에서만 사용하는 방식으로 다른 R 함수에는 적용되지는 않는다.↩︎ "],
["ch-R-Advanced-Data-Mgmt.html", "Chapter 6 R 고급 데이터 변환 6.1 데이터의 단순 결합 6.2 관계형 데이터베이스처럼 데이터 결합하기 6.3 tidyr 패키지를 이용하여 정돈 데이터 형식으로 바꾸기", " Chapter 6 R 고급 데이터 변환 4 장과 5 장에서 정돈 형식의 데이터를 변환하고 시각화하는 방법을 배웠다. 그러나 실제 데이터 분석에서는 분석하고자 하는 데이터가 하나의 데이터 프레임으로 정돈 형식으로 제공되는 경우가 많지 않다. 대부분의 경우 다음 두 가지 작업 중 하나 또는 두 가지 모두가 필요한 경우가 많다. [Merge] 다양한 원천에서 획득된 데이터를 하나의 정돈 형식의 데이터로 결합하기 [Reshape] 비정돈 형식의 데이터를 정돈 데이터 형식으로 변형하기 본 장에서는 이러한 데이터의 전처리에 필요한 다양한 기법을 논의한다. 데이터의 결합을 위해서는 dplyr 패키지를 사용할 것이며, 비정돈 형식의 데이터를 정돈 데이터 형식으로 변형하기 위해서는 tidyr 패키지를 사용할 것이다. 이 두 패키지는 모두 tidyverse 패키지에 속해 있으므로, 이 두 패키지를 사용하기 위해서 tidyverse 패키지를 적재한다. &gt; library(tidyverse) 6.1 데이터의 단순 결합 행으로 결합 vs. 열로 결합 데이터에 대한 결합이 필요한 다음 두 가지 상황을 고려해 보자. 데이터가 동일한 열 형식으로 여러 파일로 나뉘어져 있는 경우: 예를 들어 판매 실적 데이터가 2015년 데이터는 2015.csv 파일에 2016년 데이터는 2016.csv 파일에 있다고 가정해 보자. 이 경우 각 파일을 별도의 데이터 프레임으로 읽어들인 후 rbind() 함수를 이용하여 결합시킬 수 있다. 데이터가 동일한 행으로 되어 있으나, 서로 다른 열을 가지고 있는 경우: 예를 들어 사원 번호 순으로 한 파일에는 입사시점의 개인 정보가, 다른 파일에는 작년 인사 평가 결과 데이터가 있다고 하자. 두 파일에 동일한 사원 번호 순으로 데이터가 기록되어 있다면 두 파일의 정보를 데이터 프레임으로 읽어들인 후 cbind()로 결합할 수 있을 것이다. 데이터 프레임을 행과 열로 결합은 R의 기본 함수인 rbind()와 cbind()를 사용하여도 수행할 수 있다. 그러나 이 책에서는 dplyr 패키지의 bind_rows()와 bind_cols() 함수를 사용하여 여러 데이터 프레임을 행과 열로 결합할 것이다. bind_rows()와 bind_cols() 함수를 사용하는 이유는 이 두 함수가 R의 기본 함수보다 처리 속도가 빠를 뿐 아니라, R의 기본 함수보다는 편리한 기능을 가지고 있기 때문이다. 6.1.1 데이터를 행으로 결합하기 열 구조가 다른 데이터를 행으로 결합하기 데이터를 행으로 결합하는 작업이 필요한 경우, 데이터가 동일한 열 구조를 가지고 있지 않은 경우가 종종 발생한다. 동일한 열을 가지고 있더라도 열 이름이 서로 다른 경우도 있다. 이런 경우에는 결합하려는 데이터 프레임을 동일한 열 구조로 변형하여 결합하여야 한다. 예를 들어 다음과 같이 classData.RData에 포함된 class1과 class2 데이터에는 두 분반의 중간 및 기말 고사 정보 등이 들어 있다고 하자. &gt; load(&quot;advancedDataMgmt.RData&quot;) &gt; class1 ID Name Gender Year Address Midterm Final Team 1 15 김철수 M 1 서울 78 59 A 2 18 김영희 F 3 경기 85 87 A 3 25 이철수 M 3 충남 80 70 B 4 34 이영희 F 2 대전 92 89 B 5 151 홍길동 Male 4 세종 58 66 B &gt; class2 ID Mid Final Name Team Gen Year 1 12 75 79 장철수 C M 2 2 19 75 89 장영희 C F 2 3 28 87 76 최철수 D M 1 4 45 82 79 최영희 D F 30 두 파일 모두 학번(ID), 중간고사(Midterm), 기말고사(Final), 프로젝트 팀(Team), 성별(Gender), 학년(Year)에 대한 정보를 포함하고 있으나, class1에는 학생의 주소(Address) 정보가 포함되어 있고 class2는 그렇지 않다. 또한 두 파일의 열의 위치도 다르고 열의 이름도 조금 다르다. rbind()는 열의 개수가 다른 데이터 프레임을 행으로 결합하지 못한다. 두 분반 학생의 점수를 통합하여 성적 처리를 하기 위해 두 분반의 데이터를 결합하려고 한다고 하자. 이를 어떻게 수행하여야 할까? rbind()로 먼저 두 데이터 프레임을 통합하려고 시도해 보자. &gt; rbind(class1, class2) Error in rbind(deparse.level, ...): numbers of columns of arguments do not match 열의 수가 다르기 때문에 결합이 되지 않음을 알 수 있다. 따라서 rbind()로 두 데이터를 결합하려면 class1에만 있는 Address 열을 어떻게 처리할지를 결정해야 한다. 일반적으로 다음 둘 중 하나의 방법을 택해야 문제를 해결한다. 첫번째 방법은 class1의 Address 열을 제외하고 결합하는 것이고, 두번째 방법은 class2에 Address 열을 추가하고 결측치(NA)로 값을 준 후 결합하는 것이다. bind_rows()는 열의 개수가 다른 데이터 프레임임도 행으로 결합을 한다. 두 분반 학생의 데이터를 dplyr 패키지의 bind_rows() 함수를 사용하여 연결해 보자. &gt; bind_rows(class1, class2) ID Name Gender Year Address Midterm Final Team Mid Gen 1 15 김철수 M 1 서울 78 59 A NA &lt;NA&gt; 2 18 김영희 F 3 경기 85 87 A NA &lt;NA&gt; 3 25 이철수 M 3 충남 80 70 B NA &lt;NA&gt; 4 34 이영희 F 2 대전 92 89 B NA &lt;NA&gt; 5 151 홍길동 Male 4 세종 58 66 B NA &lt;NA&gt; 6 12 장철수 &lt;NA&gt; 2 &lt;NA&gt; NA 79 C 75 M 7 19 장영희 &lt;NA&gt; 2 &lt;NA&gt; NA 89 C 75 F 8 28 최철수 &lt;NA&gt; 1 &lt;NA&gt; NA 76 D 87 M 9 45 최영희 &lt;NA&gt; 30 &lt;NA&gt; NA 79 D 82 F 열의 개수가 달라도 결합이 이루어지는 것을 볼 수 있다. 두 데이터에서 서로 없는 열은 결측치 NA로 처리되어 결합이 이루어지는 것을 볼 수 있다. 그러나 사실 class1의 Midterm과 class2의 Mid는 중간고사 점수 열로 같으나 이름이 다른 것 뿐이다. bind_rows()는 이름이 다르면 서로 다른 열이라고 생각하여 각각의 새로운 열을 만들어 결합을 한다. 그러므로 사실상 같은 열이 서로 다른 이름으로 되어 있는지 살펴보아야 한다. rbind()는 두 데이터의 열의 이름이 다른 경우 행으로 결합하지 못한다. class1 데이터의 Address 열을 제외하고 두 데이터를 다시 rbind()로 결합해 보자. &gt; rbind(select(class1, -Address), class2) Error in match.names(clabs, names(xi)): names do not match previous names rbind()는 열의 개수가 동일하더라도 두 데이터 프레임의 열의 이름이 서로 다르면 행으로 결합하지 못함을 볼 수 있다. 지금 중간고사 점수 열과 성별 열의 이름이 서로 다르기 때문에 연결이 안되는 것이므로 다음처럼 열의 이름을 변경한 후 두 데이터 프레임을 행으로 연결시킨다. &gt; rbind(select(class1, -Address), rename(class2, Midterm = Mid, Gender = Gen)) ID Name Gender Year Midterm Final Team 1 15 김철수 M 1 78 59 A 2 18 김영희 F 3 85 87 A 3 25 이철수 M 3 80 70 B 4 34 이영희 F 2 92 89 B 5 151 홍길동 Male 4 58 66 B 6 12 장철수 M 2 75 79 C 7 19 장영희 F 2 75 89 C 8 28 최철수 M 1 87 76 D 9 45 최영희 F 30 82 79 D rbind()와 bind_rows()는 열의 순서를 자동으로 맞춘다. 이제 두 데이터 프레임의 열의 형태가 같아졌으므로 bind_rows()로 두 데이터를 원하는 방식으로 합칠 수 있다. 두 데이터 프레임의 열의 순서가 다른 경우 rbind()와 bind_rows()는 첫번째 데이터 프레임의 열 이름을 기준으로 열의 순서를 자동으로 맞추어 준다. &gt; class12 &lt;- bind_rows(class1, rename(class2, Midterm = Mid, Gender = Gen)) &gt; class12 ID Name Gender Year Address Midterm Final Team 1 15 김철수 M 1 서울 78 59 A 2 18 김영희 F 3 경기 85 87 A 3 25 이철수 M 3 충남 80 70 B 4 34 이영희 F 2 대전 92 89 B 5 151 홍길동 Male 4 세종 58 66 B 6 12 장철수 M 2 &lt;NA&gt; 75 79 C 7 19 장영희 F 2 &lt;NA&gt; 75 89 C 8 28 최철수 M 1 &lt;NA&gt; 87 76 D 9 45 최영희 F 30 &lt;NA&gt; 82 79 D 실제 데이터를 행으로 결합하는 과정에는 훨씬 더 다양한 문제들이 발생한다. 예를 들어 동일한 키를 나타내는 열이 하나는 cm로 하나는 m 단위로 정보가 주어져 있으면 이를 하나의 단위로 통일해야 한다. 그러나 복잡한 문제들도 결국 서로 다른 열 구조를 행으로 결합하기 위해서 어떤 열을 추가하거나 제외할 것인지를 결정하고, 열의 형식과 이름을 어떻게 통일할 것인가를 고려하는 과정이라는 점에서 본질적으로는 앞의 예와 동일하다 할 수 있다. 6.1.2 데이터를 열로 결합하기 행 순서가 다른 데이터를 열로 결합하기 데이터를 열로 결합하는 경우 실제 데이터가 동일한 행 순서로 정렬되어 있지 않은 경우가 종종 있다. 예를 들어 앞의 예에서 성적 처리를 위해서는 학생의 중간, 기말 고사 점수와 함께 출석 점수를 고려해야 한다고 하자. 그리고 출석점수는 attendance 데이터 프레임에 다음과 같이 class1과 class2의 모든 학생의 학번(ID) 순으로 정렬되어 분반 정보(Class)와 출석 점수(Attend)가 저장되어 있다고 하자. &gt; attendance ID Class Attend 1 12 2 185 2 15 1 90 3 18 1 95 4 19 2 100 5 25 1 100 6 28 2 100 7 34 1 100 8 45 2 100 9 151 1 95 앞서 두 분반의 중간 및 기말 고사 데이터가 합쳐진 class12는 학번이 기준이 아니라 분반으로 정렬되어 있다. 따라서 이 두 데이터 프레임을 단순하게 열로 결합하면 출석점수가 엉뚱한 학생에게 부여된다. 정렬 후 열로 결합하기 이를 해결하는 가장 간단한 방법은 두 데이터 프레임을 동일한 기준으로 정렬한 후 cbind()나 bind_cols()를 수행하는 것이다. 먼저 class12를 ID 순으로 정렬한 후 열로 결합해 보자. 그런데 ID 열은 두 데이터 프레임에 모두 있으므로 하나는 불필요하다. 따라서 attendance 데이터 프레임의 ID 정보는 제거한 후 결합한다. &gt; class12.a &lt;- bind_cols(arrange(class12, ID), select(attendance, -ID)) &gt; class12.a ID Name Gender Year Address Midterm Final Team Class Attend 1 12 장철수 M 2 &lt;NA&gt; 75 79 C 2 185 2 15 김철수 M 1 서울 78 59 A 1 90 3 18 김영희 F 3 경기 85 87 A 1 95 4 19 장영희 F 2 &lt;NA&gt; 75 89 C 2 100 5 25 이철수 M 3 충남 80 70 B 1 100 6 28 최철수 M 1 &lt;NA&gt; 87 76 D 2 100 7 34 이영희 F 2 대전 92 89 B 1 100 8 45 최영희 F 30 &lt;NA&gt; 82 79 D 2 100 9 151 홍길동 Male 4 세종 58 66 B 1 95 다른 방법으로 attendance 데이터 프레임을 Class와 ID 열로 정렬한 후 class12 데이터 프레임과 결합할 수도 있다. &gt; class12.b &lt;- bind_cols(class12, attendance %&gt;% arrange(Class, ID) %&gt;% select(-ID)) &gt; class12.b ID Name Gender Year Address Midterm Final Team Class Attend 1 15 김철수 M 1 서울 78 59 A 1 90 2 18 김영희 F 3 경기 85 87 A 1 95 3 25 이철수 M 3 충남 80 70 B 1 100 4 34 이영희 F 2 대전 92 89 B 1 100 5 151 홍길동 Male 4 세종 58 66 B 1 95 6 12 장철수 M 2 &lt;NA&gt; 75 79 C 2 185 7 19 장영희 F 2 &lt;NA&gt; 75 89 C 2 100 8 28 최철수 M 1 &lt;NA&gt; 87 76 D 2 100 9 45 최영희 F 30 &lt;NA&gt; 82 79 D 2 100 실제 데이터는 이보다 더 복잡한 문제를 가지고 있는 경우가 많다. 예를 들어 한 파일에 있는 행이 다른 파일에는 없는 경우도 있다. 이러한 경우엔 그 행의 정보를 모두 제거할 것인지, 아니면 그 행에 대해 없는 정보는 NA로 하여 결합을 할지 결정해야 한다. 결국 cbind()나 bind_rows()를 이용하여 열로 결합하기 위해서는 두 데이터의 행이 동일한 개체에 대한 정보가 되도록 일치시키는 것이 중요하다. 그런데 매번 두 데이터가 동일한 행으로 결합되도록 정렬하여 결합하는 작업을 사용자가 직접 하는 것은 오류 발생 가능성이 많다. 따라서 이 작업은 다음에 소개하는 ’관계형 데이터베이스처럼 데이터 결합하기’에 소개하는 방법을 사용할 것을 권장한다. 6.2 관계형 데이터베이스처럼 데이터 결합하기 관계형 데이터베이스에서는 서로 다른 열 정보를 담고 있는 두 데이터 테이블을 key를 사용하여 join이라는 방식을 이용하여 연결시킨다. 여기서 key란 앞서 성적 데이터와 출석 데이터에서 특정 학생 정보임을 식별할 수 있는 학번(ID) 등을 말한다. R에서도 두 데이터 프레임을 관계형 데이터베이스의 join과 같은 방식으로 결합시킬 수 있다. 이 작업은 R의 기본 함수인 merge() 함수를 이용하여 수행할 수도 있고, dplyr 패키지의 join 함수들을 사용하여 수행할 수도 있다. 이 책에서는 dplyr의 join 함수들을 이용하여 관계형 데이터베이스처럼 결합하기를 수행하는 방법을 설명하도록 한다. 6.2.1 Inner join과 outer join 앞의 예에서 우리는 중간, 기말 고사 점수를 가지고 있는 class12 데이터 프레임과 출석 점수를 가지고 있는 attendance 데이터 프레임을 합치기 위해 ID 열로 데이터 프레임을 정렬한 후 bind_cols()로 연결하였다. 이 작업은 dplyr의 inner_join() 함수를 이용하면 더 손쉽게 수행할 수 있다. inner_join() inner_join() 함수는 결합할 두 데이터 프레임을 인수로 먼저 기술한 다음 by 인수에 어떤 열을 기준으로 결합할 것인지를 열 이름으로 기술한다. inner_join() 함수는 두 데이터 프레임에서 by 인수로 주어진 열의 값이 동일한 행을 서로 연결하여 새로운 데이터 프레임을 만든다. 또한 새로 만들어진 데이터 프레임은 by 열을 기준으로 정렬이 이루어진다. &gt; inner_join(class12, attendance, by=&quot;ID&quot;) ID Name Gender Year Address Midterm Final Team Class Attend 1 15 김철수 M 1 서울 78 59 A 1 90 2 18 김영희 F 3 경기 85 87 A 1 95 3 25 이철수 M 3 충남 80 70 B 1 100 4 34 이영희 F 2 대전 92 89 B 1 100 5 151 홍길동 Male 4 세종 58 66 B 1 95 6 12 장철수 M 2 &lt;NA&gt; 75 79 C 2 185 7 19 장영희 F 2 &lt;NA&gt; 75 89 C 2 100 8 28 최철수 M 1 &lt;NA&gt; 87 76 D 2 100 9 45 최영희 F 30 &lt;NA&gt; 82 79 D 2 100 만약 두 데이터 프레임이 결합의 기준이 되는 열의 이름이 다르면 `by = c(“key.x” = “key.y”) 형식으로 두 데이터 프레임의 키 열의 이름을 기술하여 결합하면 된다. 만약 결합의 기준이 되는 열이 두 개 이상이면 `by = c(“key1”, “key2”) 형식으로 기술한다. 만약 결합의 기준이 되는 열이 두 개 이상이고 서로 이름이 다르면 by = c(\"key1.x\" = \"key1.y\", \"key2.x\" = \"key2.y\") 형식으로 두 데이터 프레임의 키 열의 이름을 기술한다. 관련 정보는 inner_join() 함수의 도움말을 참조하라. 1:1 inner join 앞의 예처럼 데이터가 결합되는 방식을 1 대 1 inner join이라고 부른다. 두 데이터 프레임에 ID가 동일한 학생은 오직 한 명만 존재하고, 두 데이터 프레임의 학생의 ID가 일 대 일로 대응된다. 따라서 두 데이터 프레임의 행들이 일 대 일로 결합되어 새로운 데이터 프레임이 생성된다. by 인수가 주어지지 않으면 inner_join() 함수는 두 데이터 프레임에서 이름이 같은 열을 찾고 그 열을 기준으로 결합을 한다. 따라서 위의 경우 by 인수를 설정하지 않으면, 두 데이터 프레임에 공통으로 있는 ID 열을 기준으로 데이터가 결합된다. &gt; inner_join(class12, attendance) Joining, by = &quot;ID&quot; ID Name Gender Year Address Midterm Final Team Class Attend 1 15 김철수 M 1 서울 78 59 A 1 90 2 18 김영희 F 3 경기 85 87 A 1 95 3 25 이철수 M 3 충남 80 70 B 1 100 4 34 이영희 F 2 대전 92 89 B 1 100 5 151 홍길동 Male 4 세종 58 66 B 1 95 6 12 장철수 M 2 &lt;NA&gt; 75 79 C 2 185 7 19 장영희 F 2 &lt;NA&gt; 75 89 C 2 100 8 28 최철수 M 1 &lt;NA&gt; 87 76 D 2 100 9 45 최영희 F 30 &lt;NA&gt; 82 79 D 2 100 0:1 inner join 앞서 inner_join() 함수는 두 데이터 프레임에서 by 인수로 주어진 열의 값이 같은 행을 서로 연결한다고 했다. 그러면 한 데이터 프레임에는 해당 개체의 정보가 있으나 다른 데이터 프레임에는 해당 개체의 정보가 없는 경우에 두 데이터 프레임을 연결하면 어떻게 될까? 다음 예처럼 class1에는 1분반 학생의 데이터만 있고, attendance는 1, 2분반의 학생 데이터가 모두 있는 경우 두 데이터 프레임을 ID 열로 결합하는 경우를 고려해 보자. attendance에는 동일한 ID를 가지고 있는 학생이 오직 한 명만 존재하고, class1에는 attendance에 있는 학생 정보가 0개 또는 1개가 있는 경우이다. 이러한 데이터 결합 방식을 0 대 1 inner join이라고 부른다. Inner join은 두 데이터 프레임에서 by로 지정된 열이 값이 서로 대응이 되는 행만 남겨둔다. 따라서 위의 경우에는 class1에 있는 학생의 행으로만 구성된 데이터 프레임이 생성된다. 즉, by 인수에 주어진 열이 서로 동일한 값을 가진 행만 결합되어 결과가 나오므로 한 쪽 데이터 프레임에 없는 행은 제거되었음을 알 수 있다. &gt; inner_join(class1, attendance, by=&quot;ID&quot;) ID Name Gender Year Address Midterm Final Team Class Attend 1 15 김철수 M 1 서울 78 59 A 1 90 2 18 김영희 F 3 경기 85 87 A 1 95 3 25 이철수 M 3 충남 80 70 B 1 100 4 34 이영희 F 2 대전 92 89 B 1 100 5 151 홍길동 Male 4 세종 58 66 B 1 95 outer join 한 쪽 데이터 프레임에 해당 행이 없더라도 어느 한쪽의 데이터 프레임에 행이 있으면 그 행을 포함시킬 필요가 있는 경우가 있다. 예를 들어 앞의 예에서 2분반의 중간 및 기말 고사 정보가 나중에 획득되면 추후 보강하기로 하고 현재 출석 점수가 있는 모든 학생의 정보가 나오도록 중간과 기말 점수와 출석 데이터를 결합한다고 하자. 이러한 경우 outer_join 함수들을 사용한다. Outer join 함수는 다음 세 가지가 있다. left_join(x, y): x에 있는 행을 모두 유지하여 join을 수행한다. right_join(x, y): y에 있는 행을 모두 유지하여 join을 수행한다. full_join(x, y): x와 y의 모든 행을 유지하여 join을 수행한다. 대신 한 쪽에 없는 정보는 모두 결측치 NA가 입력되어 결합된다. 다음은 inner_join(), left_join(), right_join(), full_join()의 차이가 무엇인지를 보여주는 예이다. &gt; x &lt;- data.frame(id = 1:3, name = letters[1:3]); x id name 1 1 a 2 2 b 3 3 c &gt; y &lt;- data.frame(id = 2:4, addr = LETTERS[2:4]); y id addr 1 2 B 2 3 C 3 4 D &gt; inner_join(x, y) Joining, by = &quot;id&quot; id name addr 1 2 b B 2 3 c C &gt; left_join(x, y) Joining, by = &quot;id&quot; id name addr 1 1 a &lt;NA&gt; 2 2 b B 3 3 c C &gt; right_join(x, y) Joining, by = &quot;id&quot; id name addr 1 2 b B 2 3 c C 3 4 &lt;NA&gt; D &gt; full_join(x, y) Joining, by = &quot;id&quot; id name addr 1 1 a &lt;NA&gt; 2 2 b B 3 3 c C 4 4 &lt;NA&gt; D 다음은 class1과 attendance 데이터에서 attendance의 모든 행을 남겨두는 outer join을 수행한 결과이다. &gt; right_join(class1, attendance, by=&quot;ID&quot;) ID Name Gender Year Address Midterm Final Team Class Attend 1 15 김철수 M 1 서울 78 59 A 1 90 2 18 김영희 F 3 경기 85 87 A 1 95 3 25 이철수 M 3 충남 80 70 B 1 100 4 34 이영희 F 2 대전 92 89 B 1 100 5 151 홍길동 Male 4 세종 58 66 B 1 95 6 12 &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; NA NA &lt;NA&gt; 2 185 7 19 &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; NA NA &lt;NA&gt; 2 100 8 28 &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; NA NA &lt;NA&gt; 2 100 9 45 &lt;NA&gt; &lt;NA&gt; NA &lt;NA&gt; NA NA &lt;NA&gt; 2 100 1:n inner join 만약에 한 데이터 프레임에서 결합의 기준이 되는 열에 동일한 값이 여러번 나오면 어떻게 될까? 다음의 예를 살펴보면서 그 결과가 어떻게 되는지 확인해 보자. 지금까지 우리는 class12.a라는 데이터 프레임에 중간, 기말, 출석 점수를 통합하였다. 그런데 다음과 같이 프로젝트 팀별로 프로젝트 평가 점수가 있다고 하자. &gt; pjt Team Project 1 A 80 2 B 90 3 C 85 4 D 75 한 프로젝트 팀에는 2, 3 명의 학생이 포함되고, 프로젝트 점수는 프로젝트 팀별로 주어지고 학생 개별로는 부여되지 않는다. 따라서 학생의 성적을 산정하려면 각 학생이 어떤 프로젝트 팀에 속한지를 확인한 후 학생이 속한 프로젝트 팀의 점수를 그 학생의 프로젝트 점수로 부여하는 작업이 필요하다. 이 경우 class12.a와 pjt 데이터 프레임이 결합되어야 하는데, 결합의 기준 열은 프로젝트 팀을 나타내는 Team 열이 되어야 한다. 그런데 pjt 데이터 프레임에는 한 팀에 해당되는 행이 오직 한 개만 존재하지만, class12.a 데이터 프레임에는 한 팀에 속한 학생이 여러 명 있으므로 여러 행이 존재한다. 이러한 경우의 데이터 결합 방식을 1 대 n inner join이라고 한다. 다음은 inner_join()를 사용하여 n 대 1의 관계의 두 데이터 프레임을 inner join 한 결과이다. &gt; class12.c &lt;- inner_join(class12.a, pjt, by=&quot;Team&quot;) &gt; class12.c ID Name Gender Year Address Midterm Final Team Class Attend Project 1 12 장철수 M 2 &lt;NA&gt; 75 79 C 2 185 85 2 15 김철수 M 1 서울 78 59 A 1 90 80 3 18 김영희 F 3 경기 85 87 A 1 95 80 4 19 장영희 F 2 &lt;NA&gt; 75 89 C 2 100 85 5 25 이철수 M 3 충남 80 70 B 1 100 90 6 28 최철수 M 1 &lt;NA&gt; 87 76 D 2 100 75 7 34 이영희 F 2 대전 92 89 B 1 100 90 8 45 최영희 F 30 &lt;NA&gt; 82 79 D 2 100 75 9 151 홍길동 Male 4 세종 58 66 B 1 95 90 결과에서 보듯이 by 인수로 Team을 주게 되면, pjt 데이터 프레임에서 Team이 A인 행은 하나지만, class12.a에서 Team이 A이고 학번이 15번과 18번인 학생과 관련된 두 행이 존재하므로, pjt의 한 행이 이 두 행에 차례로 결합되어 새로운 행을 만들었음을 알 수 있다. 이처럼 inner_joint()는 by 인수로 주어진 행에 동일한 값이 여러번 있으면 해당 값으로 결합이 여러번 발생한다. 두 열 이상을 기준으로 join Join의 기준이 되는 열은 하나가 아니라 여러 개가 될 수 있다. 다음과 같은 두 개의 데이터 프레임이 있다고 하자. 그리고 이 두 데이터 프레임을 하나의 데이터 프레임으로 결합한다고 하자. &gt; cAge first.name last.name age 1 James Bolton 34 2 James Tiger 26 3 Goerge Tiger 47 &gt; cIncome first.name last.name income 1 Goerge Tiger 35 2 James Bolton 24 3 James Tiger 18 두 데이터 프레임 각각에는 한 사람에 대한 정보는 오직 한 행에만 정보가 기술되어 있다. 그러나 두 데이터 프레임에서 first.name이 동일한 사람이 2명, last.name이 동일한 사람이 2명이 있다. 그래서 first.name이나 last.name만으로 데이터를 결합한다면 동일한 이름을 가진 사람이 있어서 원하는 결과를 얻을 수 없다. 다음은 first.name으로 결합한 결과이다. &gt; inner_join(cAge, cIncome, by=&quot;first.name&quot;) first.name last.name.x age last.name.y income 1 James Bolton 34 Bolton 24 2 James Bolton 34 Tiger 18 3 James Tiger 26 Bolton 24 4 James Tiger 26 Tiger 18 5 Goerge Tiger 47 Tiger 35 결과에서 보듯이 cAge의 James Bolton 행은 cIncome의 James Bolton과 James Tiger 행과 first.name이 동일하므로 두 번 결합이 이루어진다. 마찬가지로 cAge의 James Tiger 행도 cIncome의 James Bolton과 James Tiger 행과 first.name이 동일하므로 역시 두 번 행 결합이 발생한다. 그래서 결합된 결과가 3건이 아니라 총 5건의 데이터 행을 갖는다. 그리고 cAge와 cIncome 모두 last.name 열이 있어서 어떤 last.name을 남겨두어야 할지 모르므로, 첫번째 데이터 프레임에서 온 열은 .x, 두번째 데이터 프레임에서 온 열은 .y라는 접미사를 붙여서 열을 만들었다. 이러한 경우는 first.name과 last.name이 모두 같은 경우에만 행이 결합되도록 하는 것이 더 바람직하다. 그렇게 하려면 이 두 열의 이름을 모두 by 인수로 전달하면 된다. &gt; inner_join(cAge, cIncome, by=c(&quot;last.name&quot;, &quot;first.name&quot;)) first.name last.name age income 1 James Bolton 34 24 2 James Tiger 26 18 3 Goerge Tiger 47 35 6.2.2 Filtering join 지금까지는 두 데이터 프레임의 키 값이 같은 행을 inner 또는 outer join으로 연결하는 방법을 살펴보았다. 그런데 어떤 경우에는 한 데이터 프레임의 데이터를 다른 데이터 프레임의 정보를 사용하여 필터링해야 하는 경우가 있다. 다음의 두 예를 고려해 보자. 어떤 도시의 거주자의 자산 데이터와 그 도시의 세금 체납자 데이터가 있다고 하자. 이 때 거주자의 자산 정보에서 세금 체납자의 자산 정보만 뽑아서 분석하려고 한다. 어떻게 이 정보를 뽑아낼 수 있을까? 어떤 텍스트에서 사용된 단어 데이터와 의마가 없는 단어인 불용어 데이터가 있다고 하자. 이 때 텍스트의 단어 데이터에서 불용어는 제외하고 데이터를 분석하려고 한다. 어떻게 이 정보를 뽑아낼 수 있을까? dplyr 패키지에는 이 작업을 위해 다음 두 함수를 제공한다. semi_join(x, y): x 데이터 프레임에서 y에 있는 데이터만 뽑아낸다. Inner join과 다른 점은 두 데이터 프레임의 정보를 결합하지 않는다는 것이다. x 데이터 프레임에서 남겨둘 행을 지정하기 위해서만 y를 사용한다. anti_join(x, y): x 데이터 프레임에서 y에 있는 행은 제외한다. &gt; x %&gt;% semi_join(y, by = &quot;id&quot;) id name 1 2 b 2 3 c &gt; x %&gt;% anti_join(y, by = &quot;id&quot;) id name 1 1 a 6.2.3 Join을 수행하는 다른 방법들 6.2.3.1 merge() 함수 R의 기본 함수인 merge() 함수는 dplyr 패키지의 inner와 outer join을 수행해 준다. &gt; merge(x, y) # inner join id name addr 1 2 b B 2 3 c C &gt; merge(x, y, all.x = TRUE) # left join id name addr 1 1 a &lt;NA&gt; 2 2 b B 3 3 c C &gt; merge(x, y, all.y = TRUE) # right join id name addr 1 2 b B 2 3 c C 3 4 &lt;NA&gt; D &gt; merge(x, y, all = TRUE) # full join id name addr 1 1 a &lt;NA&gt; 2 2 b B 3 3 c C 4 4 &lt;NA&gt; D sqldf 패키지 지금까지 dplyr의 join 함수를 이용하여 관계형 데이터베이스의 join과 유사한 데이터 결합을 어떻게 수행하는지 살펴보았다. 그런데 관계형 데이터베이스의 SQL에 익숙한 사람들은 R에서 SQL처럼 좀 더 다양한 방식으로 join을 수행할 수 없을까라는 의문을 가질 수 있다. sqldf 패키지는 SQL 문법을 이용하여 R의 데이터 프레임에서 데이터를 조회하거나 결합할 수 있도록 해 준다. 이러한 기능이 필요한 사람은 이 패키지의 문서를 참조하기 바란다. 그러나 R은 데이터 분석을 위한 도구이지 관계형 데이터베이스와 같은 일을 수행하기 위한 도구가 아님을 명심할 필요가 있다. 대량의 데이터의 결합이 필요하다면 관계형 데이터베이스에서 SQL을 이용하여 이를 먼저 수행한 후 최종 결과를 R로 보내어 분석을 수행하는 것이 일반적으로 더 효율적인 방법이다. 6.3 tidyr 패키지를 이용하여 정돈 데이터 형식으로 바꾸기 tidyr 패키지는 tidyverse 패키지에 포함된 패키지로 비정돈 형식의 데이터를 정돈 형식으로 바꾸어주는 함수를 가지고 있다. 6.3.1 pivot_longer: 여러 열에 걸친 한 변수의 데이터를 하나의 열로 길게 모으기 정돈 데이터는 한 열이 하나의 변수에 대응을 해야 한다. 그러나 현실의 데이터에서는 동일한 변수의 값이 여러 열에 흩뿌려져 있는 경우가 발생한다. 시계열 데이터들이 대표적인 사례라 할 수 있다. 다음은 tidyr에 포함된 table4a 데이터이다. 세 나라의 1999년도와 2000년도의 어떤 사건의 발생 건수를 보여주고 있다. 발생 건수를 나타내는 데이터 열이 두 개의 열로 나눠져 있음을 볼 수 있다. &gt; table4a # A tibble: 3 x 3 country `1999` `2000` * &lt;chr&gt; &lt;int&gt; &lt;int&gt; 1 Afghanistan 745 2666 2 Brazil 37737 80488 3 China 212258 213766 table4a를 정돈 데이터로 바꾸려면 두 열을 한 열로 모아야 한다. tidyr의 pivot_longer() 함수는 그러한 역할을 수행한다. &gt; table4a %&gt;% + pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, values_to =&quot;cases&quot;) # A tibble: 6 x 3 country year cases &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 Afghanistan 1999 745 2 Afghanistan 2000 2666 3 Brazil 1999 37737 4 Brazil 2000 80488 5 China 1999 212258 6 China 2000 213766 pivot_longer()에 모아야 할 열의 이름을 지정한다. 이 예에서는 1999와 2000이다. 두 열의 이름은 숫자로 시작하고 있어서 표준적인 형태를 따르지 않아서 ` `으로 둘러쌓여 표현되었다. 원 데이터의 열 이름을 표현할 변수를 names_to로 지정한다. 원 데이터의 열의 값을 표현할 변수를 values_to로 지정한다. 원 데이터의 열 이름은 변수로서 따옴표 없이 지정되고, 결과 데이터에 만들 열 이름은 아직 만들어진 변수가 아니므로 변수의 이름이 따옴표로 둘러쌓여 문자열로 전달된다. 다음 그림은 앞의 pivot_longer() 함수의 작동 방식을 보여준다. 원 데이터보다 길어진 형식으로 데이터가 변환되므로 longer라는 표현이 사용되었다. Figure 6.1: pivot_longer 작동 방식 (출처: R for Data Science) 결측치가 있는 경우 table4a에서 중국의 2000년도 데이터가 조사되지 않아서 NA로 표시되어 있다면 pivot_longer()는 어떤 결과를 줄까? 다음 결과에서 보듯이 결측치가 있는 셀도 모두 별도의 행으로 표현이 된다. &gt; na_table4a &lt;- table4a &gt; na_table4a$`2000`[3] &lt;- NA &gt; na_table4a # A tibble: 3 x 3 country `1999` `2000` &lt;chr&gt; &lt;int&gt; &lt;int&gt; 1 Afghanistan 745 2666 2 Brazil 37737 80488 3 China 212258 NA &gt; na_table4a %&gt;% + pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, values_to = &quot;cases&quot;) # A tibble: 6 x 3 country year cases &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 Afghanistan 1999 745 2 Afghanistan 2000 2666 3 Brazil 1999 37737 4 Brazil 2000 80488 5 China 1999 212258 6 China 2000 NA 만약 긴 형식에서는 결측치인 행을 없애고 싶으면 values_drop_na 인수를 TRUE로 설정한다. &gt; na_long_table4a &lt;- na_table4a %&gt;% + pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, + values_to = &quot;cases&quot;, values_drop_na = T) &gt; na_long_table4a # A tibble: 5 x 3 country year cases &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 Afghanistan 1999 745 2 Afghanistan 2000 2666 3 Brazil 1999 37737 4 Brazil 2000 80488 5 China 1999 212258 gather 함수 tidyr 패키지는 1.0 버전이 출시되면서 많은 변화가 있었다. 이전 버전의 에서는 gather() 함수가 pivot_longer() 함수의 역할을 수행하였다. 그리고 호환성을 위해 현재의 버전에서도 gather() 함수를 사용할 수 있다. 아직도 많은 R 관련 책에서 이 함수를 사용하고 있어서 사용법을 여기에 기술한다. &gt; table4a %&gt;% + gather(`1999`, `2000`, key = &quot;year&quot;, value =&quot;cases&quot;) # A tibble: 6 x 3 country year cases &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 Afghanistan 1999 745 2 Brazil 1999 37737 3 China 1999 212258 4 Afghanistan 2000 2666 5 Brazil 2000 80488 6 China 2000 213766 pivot_longer와 유사한 형식인데, gather에서는 합칠 열의 이름을 각각의 인수로 전달된다. names_to와 values_to라는 원 데이터 입장에서의 인수 이름이 gather에서는 합쳐진 데이터 입장에서의 인수 이름인 key와 value라고 기술된다. 6.3.2 pivot_wider: 한 열에 기술된 여러 변수의 데이터를 여러 열로 넓게 펼치기 정돈 데이터는 하나의 열은 하나의 변수에 대응을 해야 한다. 그러나 현실의 데이터에서는 한 열에 여러 변수의 값이 표현되어 있는 경우도 있다. 다음 데이터는 세 나라의 어떤 년도의 사건의 발생 건수와 인구수가 count라는 한 열에 표현되었다. 그렇기 때문에 count 열은 인구수와 사건 횟수라는 두 변수의 값을 모두 포함한 열이 되었다. &gt; table2 # A tibble: 12 x 4 country year type count &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; 1 Afghanistan 1999 cases 745 2 Afghanistan 1999 population 19987071 3 Afghanistan 2000 cases 2666 4 Afghanistan 2000 population 20595360 5 Brazil 1999 cases 37737 6 Brazil 1999 population 172006362 7 Brazil 2000 cases 80488 8 Brazil 2000 population 174504898 9 China 1999 cases 212258 10 China 1999 population 1272915272 11 China 2000 cases 213766 12 China 2000 population 1280428583 table2를 정돈 데이터로 바꾸려면 count 열의 데이터를 인구수와 사건 횟수를 나타내는 열로 분리하여 한다. tidyr의 pivot_wider() 함수는 그러한 역할을 수행한다. &gt; table2 %&gt;% + pivot_wider(names_from = type, values_from = count) # A tibble: 6 x 4 country year cases population &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 Afghanistan 1999 745 19987071 2 Afghanistan 2000 2666 20595360 3 Brazil 1999 37737 172006362 4 Brazil 2000 80488 174504898 5 China 1999 212258 1272915272 6 China 2000 213766 1280428583 pivot_wider()는 결과 펼쳐진 결과 데이터에서 열의 이름으로 사용될 변수를 names_from 인수로 지정한다. 펼쳐진 결과 데이터에서 열의 값으로 사용될 변수를 values_from 인수로 지정한다. names_from과 values_from 인수를 지정할 때, 원 데이터의 열을 지정하는 것이므로 따옴표 없이 변수로서 지정한다. 다음 그림은 앞의 pivot_wider() 함수의 작동 방식을 보여준다. Figure 6.2: pivot_wider의 작동 방식 (출처: R for Data Science) 결측치가 있는 경우 앞서 pivot_longer()에서 중국의 2000년도 데이터에 결측값이 있는 행을 제거하여 데이터 프레임을 만들었다. &gt; na_long_table4a # A tibble: 5 x 3 country year cases &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 Afghanistan 1999 745 2 Afghanistan 2000 2666 3 Brazil 1999 37737 4 Brazil 2000 80488 5 China 1999 212258 만약 이 데이터를 넓은 형식으로 합치면 어떤 결과가 나올까? 결과에서 보듯이 결측이 있는 곳이 NA로 표시되고 데이터가 넓은 형식으로 변환된다. &gt; na_long_table4a %&gt;% + pivot_wider(names_from = year, values_from = cases) # A tibble: 3 x 3 country `1999` `2000` &lt;chr&gt; &lt;int&gt; &lt;int&gt; 1 Afghanistan 745 2666 2 Brazil 37737 80488 3 China 212258 NA spread 함수 tidyr 패키지는 1.0 버전이 출시되면서 많은 변화가 있었다. 이전 버전의 에서는 spread() 함수가 pivot_wider() 함수의 역할을 수행하였다. 그리고 호환성을 위해 현재의 버전에서도 spread() 함수를 사용할 수 있다. 아직도 많은 R 관련 책에서 이 함수를 사용하고 있어서 사용법을 여기에 기술한다. &gt; table2 %&gt;% + spread(key = type, value = count) # A tibble: 6 x 4 country year cases population &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 Afghanistan 1999 745 19987071 2 Afghanistan 2000 2666 20595360 3 Brazil 1999 37737 172006362 4 Brazil 2000 80488 174504898 5 China 1999 212258 1272915272 6 China 2000 213766 1280428583 pivot_wider와 유사한 형식인데 names_from와 values_from이라는 인수 이름이 spread에서는 key와 value라고 기술된다. 6.3.3 seperate: 한 셀을 여러 셀로 분리하기 한 셀에 여러 값이 기술되어 있으면 정돈 형식의 데이터가 아니다. table3의 rate 열은 사건의 수와 인구수 데이터가 문자열 형식으로 표현된 열이다. &gt; table3 # A tibble: 6 x 3 country year rate * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; 1 Afghanistan 1999 745/19987071 2 Afghanistan 2000 2666/20595360 3 Brazil 1999 37737/172006362 4 Brazil 2000 80488/174504898 5 China 1999 212258/1272915272 6 China 2000 213766/1280428583 6.3.3.1 특정 문자를 기준으로 분리하기 seperate()는 정해진 열을 sep에 지정된 문자를 기준으로 분리하여 분리된 값을 into에 지정된 열 이름으로 분리한다. 앞의 다른 함수와 마찬가지로 원 데이터의 열은 변수로서 따옴표 없이 지정되었고 결과 데이터에 사용될 열 이름은 따옴표를 사용하여 문자열로 전달되었다. &gt; table3 %&gt;% + separate(rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot;) # A tibble: 6 x 4 country year cases population &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 1999 745 19987071 2 Afghanistan 2000 2666 20595360 3 Brazil 1999 37737 172006362 4 Brazil 2000 80488 174504898 5 China 1999 212258 1272915272 6 China 2000 213766 1280428583 다음 그림은 앞의 seperate() 함수의 작동 방식을 보여준다. Figure 6.3: separate의 작동 방식 (출처: R for Data Science) sep은 구분자로 사용할 일반 문자뿐 아니라 정규 표현식을 사용하여 문자를 분리할 수 있다. 6.3.3.2 분리한 열의 형변환 앞의 결과를 보면 rate 열의 데이터가 문자열이기 때문에 결과 열도 모두 문자열 형식임을 볼 수 있다. 그런데 cases와 population 열은 모두 숫자로서 의미를 가지고 있으므로 숫자로 변환되는 것이 좋다. 셀의 내용을 분리한 후 숫자나 논리값으로 변형이 가능하면 변형을 하려면 convert 인수를 TRUE로 설정한다. &gt; x &lt;- table3 %&gt;% + separate(rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=&quot;/&quot;, convert = TRUE) &gt; x # A tibble: 6 x 4 country year cases population &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 Afghanistan 1999 745 19987071 2 Afghanistan 2000 2666 20595360 3 Brazil 1999 37737 172006362 4 Brazil 2000 80488 174504898 5 China 1999 212258 1272915272 6 China 2000 213766 1280428583 &gt; x %&gt;% summarise(total_cases=sum(cases), mean_pop=mean(population)) # A tibble: 1 x 2 total_cases mean_pop &lt;int&gt; &lt;dbl&gt; 1 547660 490072924. 6.3.3.3 문자 수를 기준으로 분리하기 sep 인수에 문자 대신 숫자를 입력하면 문자 수를를 기준으로 열을 분리한다. 양수이면 왼쪽에서 시작하여 sep에 입력된 문자 수까지와 그 이후로 열을 분리하고, 음수이면 오른쪽을 기준으로 sep에 입력된 문자 수까지와 그 이전으로 열을 분리한다. &gt; table3 %&gt;% + separate(rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=3) # A tibble: 6 x 4 country year cases population &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 1999 745 /19987071 2 Afghanistan 2000 266 6/20595360 3 Brazil 1999 377 37/172006362 4 Brazil 2000 804 88/174504898 5 China 1999 212 258/1272915272 6 China 2000 213 766/1280428583 &gt; table3 %&gt;% + separate(rate, into=c(&quot;cases&quot;, &quot;population&quot;), sep=-3) # A tibble: 6 x 4 country year cases population &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 1999 745/19987 071 2 Afghanistan 2000 2666/20595 360 3 Brazil 1999 37737/172006 362 4 Brazil 2000 80488/174504 898 5 China 1999 212258/1272915 272 6 China 2000 213766/1280428 583 앞의 예에서 숫자열인 year에 적용하여 세기와 나머지 년도로 분리해 내보자. &gt; table3 %&gt;% + separate(year, into=c(&quot;century&quot;, &quot;year&quot;), sep=2) # A tibble: 6 x 4 country century year rate &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 19 99 745/19987071 2 Afghanistan 20 00 2666/20595360 3 Brazil 19 99 37737/172006362 4 Brazil 20 00 80488/174504898 5 China 19 99 212258/1272915272 6 China 20 00 213766/1280428583 만약 세기와 연도를 숫자로 표현하는 것이 필요하다면 앞서 설명한 것처럼 convert 인수를 TRUE로 설정하면 된다. 이 경우 00년도가 모두 숫자 0으로 변환된 것을 볼 수 있다. &gt; table3 %&gt;% + separate(year, into=c(&quot;century&quot;, &quot;year&quot;), sep=2, convert = T) # A tibble: 6 x 4 country century year rate &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; 1 Afghanistan 19 99 745/19987071 2 Afghanistan 20 0 2666/20595360 3 Brazil 19 99 37737/172006362 4 Brazil 20 0 80488/174504898 5 China 19 99 212258/1272915272 6 China 20 0 213766/1280428583 6.3.4 unite: 여러 셀의 데이터를 하나의 셀로 병합하기 separate() 함수와 반대 작용을 하는 함수가 unite() 함수이다. unite() 함수는 여러 셀의 내용을 하나의 셀로 합친다. table5는 년도 데이터가 세기(century)와 나머지 년도(year)로 나뉘어져 있는 데이터이다. 세기와 무관하게 년도 별로 데이터를 분석하려고 하면 이 두 열을 합쳐서 온전한 년도 데이터를 만들어야 한다. &gt; table5 %&gt;% + unite(c(century, year), col = &quot;year&quot;) # A tibble: 6 x 3 country year rate &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 19_99 745/19987071 2 Afghanistan 20_00 2666/20595360 3 Brazil 19_99 37737/172006362 4 Brazil 20_00 80488/174504898 5 China 19_99 212258/1272915272 6 China 20_00 213766/1280428583 unite()의 기본 설정은 _을 구분자로 사용하여 합쳐진 셀의 내용을 연결한다. 이를 조정하려면, sep 인수를 설정하면 된다. 다음처럼 하면 구분자 없이 연결을 수행한다. &gt; table5 %&gt;% + unite(c(century, year), col = &quot;year&quot;, sep=&quot;&quot;) # A tibble: 6 x 3 country year rate &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 1999 745/19987071 2 Afghanistan 2000 2666/20595360 3 Brazil 1999 37737/172006362 4 Brazil 2000 80488/174504898 5 China 1999 212258/1272915272 6 China 2000 213766/1280428583 "]
]
